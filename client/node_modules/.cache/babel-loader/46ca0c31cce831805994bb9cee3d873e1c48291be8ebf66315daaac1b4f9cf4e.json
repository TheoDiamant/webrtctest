{"ast":null,"code":"var _s = $RefreshSig$();\n// src/hooks/useWebRTC.js\nimport { useEffect, useRef, useState } from \"react\";\nexport default function useWebRTC(callId, {\n  start = true,\n  isInitiator = false\n}) {\n  _s();\n  const [status, setStatus] = useState(\"waiting\");\n  const wsRef = useRef(null);\n  const pcRef = useRef(null);\n  const dcRef = useRef(null);\n  const localStreamRef = useRef(null);\n  const remoteStreamRef = useRef(new MediaStream());\n  const remoteAudioRef = useRef(null);\n  const [chatMessages, setChatMessages] = useState([]);\n  const [isChannelOpen, setIsChannelOpen] = useState(false);\n\n  // 1) WebSocket signaling\n  useEffect(() => {\n    if (!start) return;\n    const url = process.env.REACT_APP_SERVER_URL.replace(/^http/, \"ws\");\n    const ws = new WebSocket(`${url}?roomId=${callId}`);\n    wsRef.current = ws;\n    ws.onopen = () => console.log(\"WS open\");\n    ws.onmessage = async ({\n      data\n    }) => {\n      const msg = JSON.parse(data);\n      switch (msg.type) {\n        case \"room-status\":\n          // si on est deux et qu’on attend, on démarre la connexion\n          if (msg.peers === 2 && status === \"waiting\") {\n            await startCall();\n          }\n          break;\n        case \"offer\":\n          await pcRef.current.setRemoteDescription(msg.offer);\n          await createAndSendAnswer();\n          break;\n        case \"answer\":\n          await pcRef.current.setRemoteDescription(msg.answer);\n          break;\n        case \"candidate\":\n          if (msg.candidate) {\n            await pcRef.current.addIceCandidate(msg.candidate);\n          }\n          break;\n        case \"end-call\":\n          hangUp();\n          break;\n      }\n    };\n    ws.onclose = () => console.log(\"WS closed\");\n    return () => {\n      var _pcRef$current;\n      ws.close();\n      (_pcRef$current = pcRef.current) === null || _pcRef$current === void 0 ? void 0 : _pcRef$current.close();\n    };\n  }, [callId, start, status]);\n\n  // 2) Créer la PeerConnection et échanger SDP/ICE\n  async function startCall() {\n    setStatus(\"connecting\");\n    const pc = new RTCPeerConnection({\n      iceServers: [{\n        urls: process.env.REACT_APP_STUN_SERVER\n      }]\n    });\n    pcRef.current = pc;\n\n    // ICE → on envoie au pair\n    pc.onicecandidate = ({\n      candidate\n    }) => {\n      if (candidate) {\n        wsRef.current.send(JSON.stringify({\n          type: \"candidate\",\n          candidate\n        }));\n      }\n    };\n\n    // piste distante → on met dans remoteStreamRef\n    pc.ontrack = ({\n      streams\n    }) => {\n      const [stream] = streams;\n      // si c'est la première piste, on affecte au <audio>\n      remoteStreamRef.current = stream;\n      if (remoteAudioRef.current) {\n        remoteAudioRef.current.srcObject = stream;\n      }\n    };\n\n    // 2.1) getUserMedia\n    const localStream = await navigator.mediaDevices.getUserMedia({\n      audio: true\n    });\n    localStreamRef.current = localStream;\n    localStream.getTracks().forEach(track => {\n      pc.addTrack(track, localStream);\n    });\n\n    // 2.2) DataChannel pour le chat (uniquement côté initiator)\n    if (isInitiator) {\n      const dc = pc.createDataChannel(\"chat\");\n      dcRef.current = dc;\n      setupDataChannel(dc);\n    } else {\n      pc.ondatachannel = ({\n        channel\n      }) => {\n        dcRef.current = channel;\n        setupDataChannel(channel);\n      };\n    }\n\n    // 2.3) Offer/Answer\n    if (isInitiator) {\n      const offer = await pc.createOffer();\n      await pc.setLocalDescription(offer);\n      wsRef.current.send(JSON.stringify({\n        type: \"offer\",\n        offer\n      }));\n    }\n    setStatus(\"connected\");\n  }\n  async function createAndSendAnswer() {\n    const pc = pcRef.current;\n    const answer = await pc.createAnswer();\n    await pc.setLocalDescription(answer);\n    wsRef.current.send(JSON.stringify({\n      type: \"answer\",\n      answer\n    }));\n    setStatus(\"connected\");\n  }\n\n  // 3) Chat via DataChannel\n  function setupDataChannel(dc) {\n    dc.onopen = () => setIsChannelOpen(true);\n    dc.onclose = () => setIsChannelOpen(false);\n    dc.onmessage = ({\n      data\n    }) => setChatMessages(prev => [...prev, {\n      sender: \"peer\",\n      text: data\n    }]);\n  }\n  function sendMessage(text) {\n    var _dcRef$current;\n    setChatMessages(prev => [...prev, {\n      sender: \"local\",\n      text\n    }]);\n    if (((_dcRef$current = dcRef.current) === null || _dcRef$current === void 0 ? void 0 : _dcRef$current.readyState) === \"open\") {\n      dcRef.current.send(text);\n    }\n  }\n\n  // 4) commandes utilisateur\n  function toggleMute() {\n    var _localStreamRef$curre;\n    const track = (_localStreamRef$curre = localStreamRef.current) === null || _localStreamRef$curre === void 0 ? void 0 : _localStreamRef$curre.getAudioTracks()[0];\n    if (track) track.enabled = !track.enabled;\n  }\n  function hangUp() {\n    var _localStreamRef$curre2, _pcRef$current2;\n    setStatus(\"ended\");\n    (_localStreamRef$curre2 = localStreamRef.current) === null || _localStreamRef$curre2 === void 0 ? void 0 : _localStreamRef$curre2.getTracks().forEach(t => t.stop());\n    remoteStreamRef.current = new MediaStream();\n    if (remoteAudioRef.current) remoteAudioRef.current.srcObject = null;\n    (_pcRef$current2 = pcRef.current) === null || _pcRef$current2 === void 0 ? void 0 : _pcRef$current2.close();\n    wsRef.current.send(JSON.stringify({\n      type: \"end-call\"\n    }));\n    wsRef.current.close();\n  }\n  return {\n    remoteAudioRef,\n    status,\n    chatMessages,\n    sendMessage,\n    toggleMute,\n    hangUp,\n    isChannelOpen\n  };\n}\n_s(useWebRTC, \"ozBacq8gEcUC3YjBgdxsf+Twg14=\");","map":{"version":3,"names":["useEffect","useRef","useState","useWebRTC","callId","start","isInitiator","_s","status","setStatus","wsRef","pcRef","dcRef","localStreamRef","remoteStreamRef","MediaStream","remoteAudioRef","chatMessages","setChatMessages","isChannelOpen","setIsChannelOpen","url","process","env","REACT_APP_SERVER_URL","replace","ws","WebSocket","current","onopen","console","log","onmessage","data","msg","JSON","parse","type","peers","startCall","setRemoteDescription","offer","createAndSendAnswer","answer","candidate","addIceCandidate","hangUp","onclose","_pcRef$current","close","pc","RTCPeerConnection","iceServers","urls","REACT_APP_STUN_SERVER","onicecandidate","send","stringify","ontrack","streams","stream","srcObject","localStream","navigator","mediaDevices","getUserMedia","audio","getTracks","forEach","track","addTrack","dc","createDataChannel","setupDataChannel","ondatachannel","channel","createOffer","setLocalDescription","createAnswer","prev","sender","text","sendMessage","_dcRef$current","readyState","toggleMute","_localStreamRef$curre","getAudioTracks","enabled","_localStreamRef$curre2","_pcRef$current2","t","stop"],"sources":["/Users/theodiamant/Desktop/webrtc/client/src/hooks/useWebRTC.js"],"sourcesContent":["// src/hooks/useWebRTC.js\nimport { useEffect, useRef, useState } from \"react\";\n\nexport default function useWebRTC(\n  callId,\n  { start = true, isInitiator = false }\n) {\n  const [status, setStatus] = useState(\"waiting\");\n  const wsRef = useRef(null);\n  const pcRef = useRef(null);\n  const dcRef = useRef(null);\n  const localStreamRef = useRef(null);\n  const remoteStreamRef = useRef(new MediaStream());\n  const remoteAudioRef = useRef(null);\n\n  const [chatMessages, setChatMessages] = useState([]);\n  const [isChannelOpen, setIsChannelOpen] = useState(false);\n\n  // 1) WebSocket signaling\n  useEffect(() => {\n    if (!start) return;\n    const url = process.env.REACT_APP_SERVER_URL.replace(/^http/, \"ws\");\n    const ws = new WebSocket(`${url}?roomId=${callId}`);\n    wsRef.current = ws;\n\n    ws.onopen = () => console.log(\"WS open\");\n    ws.onmessage = async ({ data }) => {\n      const msg = JSON.parse(data);\n      switch (msg.type) {\n        case \"room-status\":\n          // si on est deux et qu’on attend, on démarre la connexion\n          if (msg.peers === 2 && status === \"waiting\") {\n            await startCall();\n          }\n          break;\n        case \"offer\":\n          await pcRef.current.setRemoteDescription(msg.offer);\n          await createAndSendAnswer();\n          break;\n        case \"answer\":\n          await pcRef.current.setRemoteDescription(msg.answer);\n          break;\n        case \"candidate\":\n          if (msg.candidate) {\n            await pcRef.current.addIceCandidate(msg.candidate);\n          }\n          break;\n        case \"end-call\":\n          hangUp();\n          break;\n      }\n    };\n    ws.onclose = () => console.log(\"WS closed\");\n\n    return () => {\n      ws.close();\n      pcRef.current?.close();\n    };\n  }, [callId, start, status]);\n\n  // 2) Créer la PeerConnection et échanger SDP/ICE\n  async function startCall() {\n    setStatus(\"connecting\");\n\n    const pc = new RTCPeerConnection({\n      iceServers: [{ urls: process.env.REACT_APP_STUN_SERVER }],\n    });\n    pcRef.current = pc;\n\n    // ICE → on envoie au pair\n    pc.onicecandidate = ({ candidate }) => {\n      if (candidate) {\n        wsRef.current.send(\n          JSON.stringify({ type: \"candidate\", candidate })\n        );\n      }\n    };\n\n    // piste distante → on met dans remoteStreamRef\n    pc.ontrack = ({ streams }) => {\n      const [stream] = streams;\n      // si c'est la première piste, on affecte au <audio>\n      remoteStreamRef.current = stream;\n      if (remoteAudioRef.current) {\n        remoteAudioRef.current.srcObject = stream;\n      }\n    };\n\n    // 2.1) getUserMedia\n    const localStream = await navigator.mediaDevices.getUserMedia({\n      audio: true,\n    });\n    localStreamRef.current = localStream;\n    localStream.getTracks().forEach((track) => {\n      pc.addTrack(track, localStream);\n    });\n\n    // 2.2) DataChannel pour le chat (uniquement côté initiator)\n    if (isInitiator) {\n      const dc = pc.createDataChannel(\"chat\");\n      dcRef.current = dc;\n      setupDataChannel(dc);\n    } else {\n      pc.ondatachannel = ({ channel }) => {\n        dcRef.current = channel;\n        setupDataChannel(channel);\n      };\n    }\n\n    // 2.3) Offer/Answer\n    if (isInitiator) {\n      const offer = await pc.createOffer();\n      await pc.setLocalDescription(offer);\n      wsRef.current.send(JSON.stringify({ type: \"offer\", offer }));\n    }\n\n    setStatus(\"connected\");\n  }\n\n  async function createAndSendAnswer() {\n    const pc = pcRef.current;\n    const answer = await pc.createAnswer();\n    await pc.setLocalDescription(answer);\n    wsRef.current.send(JSON.stringify({ type: \"answer\", answer }));\n    setStatus(\"connected\");\n  }\n\n  // 3) Chat via DataChannel\n  function setupDataChannel(dc) {\n    dc.onopen = () => setIsChannelOpen(true);\n    dc.onclose = () => setIsChannelOpen(false);\n    dc.onmessage = ({ data }) =>\n      setChatMessages((prev) => [...prev, { sender: \"peer\", text: data }]);\n  }\n\n  function sendMessage(text) {\n    setChatMessages((prev) => [...prev, { sender: \"local\", text }]);\n    if (dcRef.current?.readyState === \"open\") {\n      dcRef.current.send(text);\n    }\n  }\n\n  // 4) commandes utilisateur\n  function toggleMute() {\n    const track = localStreamRef.current?.getAudioTracks()[0];\n    if (track) track.enabled = !track.enabled;\n  }\n\n  function hangUp() {\n    setStatus(\"ended\");\n    localStreamRef.current?.getTracks().forEach((t) => t.stop());\n    remoteStreamRef.current = new MediaStream();\n    if (remoteAudioRef.current) remoteAudioRef.current.srcObject = null;\n    pcRef.current?.close();\n    wsRef.current.send(JSON.stringify({ type: \"end-call\" }));\n    wsRef.current.close();\n  }\n\n  return {\n    remoteAudioRef,\n    status,\n    chatMessages,\n    sendMessage,\n    toggleMute,\n    hangUp,\n    isChannelOpen,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"var _s = $RefreshSig$();\n// src/hooks/useWebRTC.js\nimport { useEffect, useRef, useState } from \"react\";\nexport default function useWebRTC(callId, {\n  timeout = 30000,\n  start = true\n}) {\n  _s();\n  const wsRef = useRef();\n  const pcRef = useRef();\n  const dataChannelRef = useRef();\n  const remoteAudioRef = useRef();\n  const localStreamRef = useRef();\n  const [status, setStatus] = useState(\"waiting\");\n  const [chatMessages, setChatMessages] = useState([]);\n  const [localSpeaking, setLocalSpeaking] = useState(false);\n  const [remoteSpeaking, setRemoteSpeaking] = useState(false);\n  useEffect(() => {\n    if (!start) return;\n    // open WebSocket to signaling server\n    const serverUrl = process.env.REACT_APP_SERVER_URL;\n    wsRef.current = new WebSocket(`${serverUrl.replace(/^http/, \"ws\")}?roomId=${callId}`);\n    wsRef.current.onopen = () => console.log(\"WS open\");\n    wsRef.current.onclose = () => console.log(\"WS closed\");\n    wsRef.current.onmessage = async ({\n      data\n    }) => {\n      // normalize to string\n      const text = typeof data === \"string\" ? data : data.toString();\n      let msg;\n      try {\n        msg = JSON.parse(text);\n      } catch {\n        return; // ignore non-JSON blobs\n      }\n      switch (msg.type) {\n        case \"room-status\":\n          // once two peers are in, initiator starts the call\n          if (msg.peers === 2 && status === \"waiting\") {\n            await initiateCall(true);\n          }\n          break;\n        case \"offer\":\n          await pcRef.current.setRemoteDescription(msg.offer);\n          const answer = await pcRef.current.createAnswer();\n          await pcRef.current.setLocalDescription(answer);\n          wsRef.current.send(JSON.stringify({\n            type: \"answer\",\n            answer\n          }));\n          break;\n        case \"answer\":\n          await pcRef.current.setRemoteDescription(msg.answer);\n          break;\n        case \"candidate\":\n          await pcRef.current.addIceCandidate(msg.candidate);\n          break;\n        case \"peer-left\":\n          setStatus(\"peer-left\");\n          break;\n      }\n    };\n    async function initiateCall(isInitiator) {\n      setStatus(\"connecting\");\n      // create peer connection\n      pcRef.current = new RTCPeerConnection({\n        iceServers: [{\n          urls: process.env.REACT_APP_STUN_SERVER\n        }]\n      });\n\n      // get local audio stream\n      localStreamRef.current = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n\n      // --- LOCAL SPEECH DETECTION ---\n      const audioCtxLocal = new (window.AudioContext || window.webkitAudioContext)();\n      const analyserLocal = audioCtxLocal.createAnalyser();\n      const srcLocal = audioCtxLocal.createMediaStreamSource(localStreamRef.current);\n      srcLocal.connect(analyserLocal);\n      analyserLocal.fftSize = 256;\n      const dataArrayLocal = new Uint8Array(analyserLocal.frequencyBinCount);\n      function detectLocal() {\n        analyserLocal.getByteFrequencyData(dataArrayLocal);\n        const avg = dataArrayLocal.reduce((sum, v) => sum + v, 0) / dataArrayLocal.length;\n        setLocalSpeaking(avg > 30);\n        requestAnimationFrame(detectLocal);\n      }\n      detectLocal();\n\n      // add tracks to peer\n      localStreamRef.current.getTracks().forEach(t => pcRef.current.addTrack(t, localStreamRef.current));\n\n      // --- REMOTE SPEECH DETECTION on first track ---\n      pcRef.current.ontrack = ({\n        streams: [stream]\n      }) => {\n        // attach remote audio\n        if (remoteAudioRef.current) remoteAudioRef.current.srcObject = stream;\n\n        // once remote stream arrives, set up analyser once\n        if (!remoteSpeaking) {\n          const audioCtxRemote = new (window.AudioContext || window.webkitAudioContext)();\n          const analyserRemote = audioCtxRemote.createAnalyser();\n          const srcRemote = audioCtxRemote.createMediaStreamSource(stream);\n          srcRemote.connect(analyserRemote);\n          analyserRemote.fftSize = 256;\n          const dataArrayRemote = new Uint8Array(analyserRemote.frequencyBinCount);\n          function detectRemote() {\n            analyserRemote.getByteFrequencyData(dataArrayRemote);\n            const avgR = dataArrayRemote.reduce((sum, v) => sum + v, 0) / dataArrayRemote.length;\n            setRemoteSpeaking(avgR > 30);\n            requestAnimationFrame(detectRemote);\n          }\n          detectRemote();\n        }\n      };\n\n      // set up data channel\n      if (isInitiator) {\n        dataChannelRef.current = pcRef.current.createDataChannel(\"chat\");\n        setupDataChannel();\n      } else {\n        pcRef.current.ondatachannel = ({\n          channel\n        }) => {\n          dataChannelRef.current = channel;\n          setupDataChannel();\n        };\n      }\n\n      // ICE candidates\n      pcRef.current.onicecandidate = ({\n        candidate\n      }) => {\n        if (candidate) wsRef.current.send(JSON.stringify({\n          type: \"candidate\",\n          candidate\n        }));\n      };\n\n      // offer/answer exchange\n      if (isInitiator) {\n        const offer = await pcRef.current.createOffer();\n        await pcRef.current.setLocalDescription(offer);\n        wsRef.current.send(JSON.stringify({\n          type: \"offer\",\n          offer\n        }));\n      }\n      setStatus(\"connected\");\n    }\n    function setupDataChannel() {\n      dataChannelRef.current.onopen = () => console.log(\"DataChannel open\");\n      dataChannelRef.current.onmessage = ({\n        data\n      }) => setChatMessages(prev => [...prev, {\n        sender: \"peer\",\n        text: data\n      }]);\n    }\n\n    // timeout if not connected\n    const timer = setTimeout(() => {\n      if (status !== \"connected\") setStatus(\"timeout\");\n    }, timeout);\n    return () => {\n      var _wsRef$current, _pcRef$current;\n      clearTimeout(timer);\n      (_wsRef$current = wsRef.current) === null || _wsRef$current === void 0 ? void 0 : _wsRef$current.close();\n      (_pcRef$current = pcRef.current) === null || _pcRef$current === void 0 ? void 0 : _pcRef$current.close();\n    };\n  }, [callId, start, status, timeout]);\n  function sendMessage(text) {\n    var _dataChannelRef$curre;\n    if (((_dataChannelRef$curre = dataChannelRef.current) === null || _dataChannelRef$curre === void 0 ? void 0 : _dataChannelRef$curre.readyState) === \"open\") {\n      dataChannelRef.current.send(text);\n      setChatMessages(prev => [...prev, {\n        sender: \"local\",\n        text\n      }]);\n    }\n  }\n  function toggleMute() {\n    if (localStreamRef.current) {\n      const track = localStreamRef.current.getAudioTracks()[0];\n      track.enabled = !track.enabled;\n    }\n  }\n  function hangUp() {\n    wsRef.current.close();\n    pcRef.current.close();\n    setStatus(\"ended\");\n  }\n  return {\n    remoteAudioRef,\n    status,\n    chatMessages,\n    sendMessage,\n    toggleMute,\n    hangUp,\n    localSpeaking,\n    remoteSpeaking\n  };\n}\n_s(useWebRTC, \"F9d13EwaK8UZf/sOb0xe/03dso8=\");","map":{"version":3,"names":["useEffect","useRef","useState","useWebRTC","callId","timeout","start","_s","wsRef","pcRef","dataChannelRef","remoteAudioRef","localStreamRef","status","setStatus","chatMessages","setChatMessages","localSpeaking","setLocalSpeaking","remoteSpeaking","setRemoteSpeaking","serverUrl","process","env","REACT_APP_SERVER_URL","current","WebSocket","replace","onopen","console","log","onclose","onmessage","data","text","toString","msg","JSON","parse","type","peers","initiateCall","setRemoteDescription","offer","answer","createAnswer","setLocalDescription","send","stringify","addIceCandidate","candidate","isInitiator","RTCPeerConnection","iceServers","urls","REACT_APP_STUN_SERVER","navigator","mediaDevices","getUserMedia","audio","audioCtxLocal","window","AudioContext","webkitAudioContext","analyserLocal","createAnalyser","srcLocal","createMediaStreamSource","connect","fftSize","dataArrayLocal","Uint8Array","frequencyBinCount","detectLocal","getByteFrequencyData","avg","reduce","sum","v","length","requestAnimationFrame","getTracks","forEach","t","addTrack","ontrack","streams","stream","srcObject","audioCtxRemote","analyserRemote","srcRemote","dataArrayRemote","detectRemote","avgR","createDataChannel","setupDataChannel","ondatachannel","channel","onicecandidate","createOffer","prev","sender","timer","setTimeout","_wsRef$current","_pcRef$current","clearTimeout","close","sendMessage","_dataChannelRef$curre","readyState","toggleMute","track","getAudioTracks","enabled","hangUp"],"sources":["/Users/theodiamant/Desktop/webrtc/client/src/hooks/useWebRTC.js"],"sourcesContent":["// src/hooks/useWebRTC.js\nimport { useEffect, useRef, useState } from \"react\";\n\nexport default function useWebRTC(callId, { timeout = 30000, start = true }) {\n  const wsRef = useRef();\n  const pcRef = useRef();\n  const dataChannelRef = useRef();\n  const remoteAudioRef = useRef();\n  const localStreamRef = useRef();\n\n  const [status, setStatus] = useState(\"waiting\");\n  const [chatMessages, setChatMessages] = useState([]);\n  const [localSpeaking, setLocalSpeaking] = useState(false);\n  const [remoteSpeaking, setRemoteSpeaking] = useState(false);\n\n  useEffect(() => {\n    if (!start) return;\n    // open WebSocket to signaling server\n    const serverUrl = process.env.REACT_APP_SERVER_URL;\n    wsRef.current = new WebSocket(\n      `${serverUrl.replace(/^http/, \"ws\")}?roomId=${callId}`\n    );\n\n    wsRef.current.onopen = () => console.log(\"WS open\");\n    wsRef.current.onclose = () => console.log(\"WS closed\");\n\n    wsRef.current.onmessage = async ({ data }) => {\n      // normalize to string\n      const text = typeof data === \"string\" ? data : data.toString();\n      let msg;\n      try {\n        msg = JSON.parse(text);\n      } catch {\n        return; // ignore non-JSON blobs\n      }\n\n      switch (msg.type) {\n        case \"room-status\":\n          // once two peers are in, initiator starts the call\n          if (msg.peers === 2 && status === \"waiting\") {\n            await initiateCall(true);\n          }\n          break;\n\n        case \"offer\":\n          await pcRef.current.setRemoteDescription(msg.offer);\n          const answer = await pcRef.current.createAnswer();\n          await pcRef.current.setLocalDescription(answer);\n          wsRef.current.send(\n            JSON.stringify({ type: \"answer\", answer })\n          );\n          break;\n\n        case \"answer\":\n          await pcRef.current.setRemoteDescription(msg.answer);\n          break;\n\n        case \"candidate\":\n          await pcRef.current.addIceCandidate(msg.candidate);\n          break;\n\n        case \"peer-left\":\n          setStatus(\"peer-left\");\n          break;\n      }\n    };\n\n    async function initiateCall(isInitiator) {\n      setStatus(\"connecting\");\n      // create peer connection\n      pcRef.current = new RTCPeerConnection({\n        iceServers: [{ urls: process.env.REACT_APP_STUN_SERVER }],\n      });\n\n      // get local audio stream\n      localStreamRef.current = await navigator.mediaDevices.getUserMedia({\n        audio: true,\n      });\n\n      // --- LOCAL SPEECH DETECTION ---\n      const audioCtxLocal =\n        new (window.AudioContext || window.webkitAudioContext)();\n      const analyserLocal = audioCtxLocal.createAnalyser();\n      const srcLocal = audioCtxLocal.createMediaStreamSource(\n        localStreamRef.current\n      );\n      srcLocal.connect(analyserLocal);\n      analyserLocal.fftSize = 256;\n      const dataArrayLocal = new Uint8Array(\n        analyserLocal.frequencyBinCount\n      );\n\n      function detectLocal() {\n        analyserLocal.getByteFrequencyData(dataArrayLocal);\n        const avg =\n          dataArrayLocal.reduce((sum, v) => sum + v, 0) /\n          dataArrayLocal.length;\n        setLocalSpeaking(avg > 30);\n        requestAnimationFrame(detectLocal);\n      }\n      detectLocal();\n\n      // add tracks to peer\n      localStreamRef.current\n        .getTracks()\n        .forEach((t) =>\n          pcRef.current.addTrack(t, localStreamRef.current)\n        );\n\n      // --- REMOTE SPEECH DETECTION on first track ---\n      pcRef.current.ontrack = ({ streams: [stream] }) => {\n        // attach remote audio\n        if (remoteAudioRef.current)\n          remoteAudioRef.current.srcObject = stream;\n\n        // once remote stream arrives, set up analyser once\n        if (!remoteSpeaking) {\n          const audioCtxRemote =\n            new (window.AudioContext || window.webkitAudioContext)();\n          const analyserRemote = audioCtxRemote.createAnalyser();\n          const srcRemote = audioCtxRemote.createMediaStreamSource(\n            stream\n          );\n          srcRemote.connect(analyserRemote);\n          analyserRemote.fftSize = 256;\n          const dataArrayRemote = new Uint8Array(\n            analyserRemote.frequencyBinCount\n          );\n\n          function detectRemote() {\n            analyserRemote.getByteFrequencyData(dataArrayRemote);\n            const avgR =\n              dataArrayRemote.reduce((sum, v) => sum + v, 0) /\n              dataArrayRemote.length;\n            setRemoteSpeaking(avgR > 30);\n            requestAnimationFrame(detectRemote);\n          }\n          detectRemote();\n        }\n      };\n\n      // set up data channel\n      if (isInitiator) {\n        dataChannelRef.current = pcRef.current.createDataChannel(\n          \"chat\"\n        );\n        setupDataChannel();\n      } else {\n        pcRef.current.ondatachannel = ({ channel }) => {\n          dataChannelRef.current = channel;\n          setupDataChannel();\n        };\n      }\n\n      // ICE candidates\n      pcRef.current.onicecandidate = ({ candidate }) => {\n        if (candidate)\n          wsRef.current.send(\n            JSON.stringify({ type: \"candidate\", candidate })\n          );\n      };\n\n      // offer/answer exchange\n      if (isInitiator) {\n        const offer = await pcRef.current.createOffer();\n        await pcRef.current.setLocalDescription(offer);\n        wsRef.current.send(JSON.stringify({ type: \"offer\", offer }));\n      }\n\n      setStatus(\"connected\");\n    }\n\n    function setupDataChannel() {\n      dataChannelRef.current.onopen = () =>\n        console.log(\"DataChannel open\");\n      dataChannelRef.current.onmessage = ({ data }) =>\n        setChatMessages((prev) => [\n          ...prev,\n          { sender: \"peer\", text: data },\n        ]);\n    }\n\n    // timeout if not connected\n    const timer = setTimeout(() => {\n      if (status !== \"connected\") setStatus(\"timeout\");\n    }, timeout);\n\n    return () => {\n      clearTimeout(timer);\n      wsRef.current?.close();\n      pcRef.current?.close();\n    };\n  }, [callId, start, status, timeout]);\n\n  function sendMessage(text) {\n    if (dataChannelRef.current?.readyState === \"open\") {\n      dataChannelRef.current.send(text);\n      setChatMessages((prev) => [\n        ...prev,\n        { sender: \"local\", text },\n      ]);\n    }\n  }\n\n  function toggleMute() {\n    if (localStreamRef.current) {\n      const track = localStreamRef.current\n        .getAudioTracks()[0];\n      track.enabled = !track.enabled;\n    }\n  }\n\n  function hangUp() {\n    wsRef.current.close();\n    pcRef.current.close();\n    setStatus(\"ended\");\n  }\n\n  return {\n    remoteAudioRef,\n    status,\n    chatMessages,\n    sendMessage,\n    toggleMute,\n    hangUp,\n    localSpeaking,\n    remoteSpeaking,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
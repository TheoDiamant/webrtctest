{"ast":null,"code":"var _s = $RefreshSig$();\n// File: src/hooks/useWebRTC.js\nimport { useEffect, useRef, useState } from 'react';\nexport default function useWebRTC(callId, {\n  start = true,\n  isInitiator = false\n}) {\n  _s();\n  const [status, setStatus] = useState('idle');\n  const [chatMessages, setChatMessages] = useState([]);\n  const [isChannelOpen, setChannelOpen] = useState(false);\n  const [remoteStream, setRemoteStream] = useState(new MediaStream());\n  const wsRef = useRef(null);\n  const pcRef = useRef(null);\n  const dataChannelRef = useRef(null);\n  const localStreamRef = useRef(null);\n  useEffect(() => {\n    if (!start) return;\n    setStatus('connecting');\n    const wsUrl = `${process.env.REACT_APP_WS_URL || process.env.REACT_APP_SERVER_URL.replace(/^http/, 'ws')}?roomId=${callId}`;\n    wsRef.current = new WebSocket(wsUrl);\n    wsRef.current.onopen = () => initConnection();\n    wsRef.current.onmessage = ({\n      data\n    }) => handleSignal(JSON.parse(data));\n    wsRef.current.onerror = err => console.error('WS error', err);\n    return cleanup;\n  }, [start]);\n  const initConnection = async () => {\n    pcRef.current = new RTCPeerConnection({\n      iceServers: [{\n        urls: process.env.REACT_APP_STUN_SERVER\n      }, {\n        urls: process.env.REACT_APP_TURN_SERVER,\n        username: process.env.REACT_APP_TURN_USER,\n        credential: process.env.REACT_APP_TURN_PASS\n      }]\n    });\n    pcRef.current.onicecandidate = ({\n      candidate\n    }) => {\n      if (candidate) wsRef.current.send(JSON.stringify({\n        type: 'candidate',\n        candidate\n      }));\n    };\n    pcRef.current.ontrack = ({\n      track\n    }) => {\n      setRemoteStream(prev => {\n        const ns = new MediaStream([...prev.getTracks(), track]);\n        return ns;\n      });\n    };\n    localStreamRef.current = await navigator.mediaDevices.getUserMedia({\n      audio: {\n        echoCancellation: true,\n        noiseSuppression: true\n      }\n    });\n    localStreamRef.current.getTracks().forEach(track => pcRef.current.addTrack(track, localStreamRef.current));\n    if (isInitiator) {\n      dataChannelRef.current = pcRef.current.createDataChannel('chat');\n      setupDataChannel();\n      await negotiate('offer');\n    } else {\n      pcRef.current.ondatachannel = ({\n        channel\n      }) => {\n        dataChannelRef.current = channel;\n        setupDataChannel();\n      };\n    }\n  };\n  const setupDataChannel = () => {\n    const dc = dataChannelRef.current;\n    dc.onopen = () => setChannelOpen(true);\n    dc.onmessage = ({\n      data\n    }) => setChatMessages(c => [...c, {\n      sender: 'remote',\n      text: data\n    }]);\n    dc.onclose = () => setChannelOpen(false);\n  };\n  const negotiate = async type => {\n    if (type === 'offer') {\n      const offer = await pcRef.current.createOffer();\n      await pcRef.current.setLocalDescription(offer);\n      wsRef.current.send(JSON.stringify({\n        type: 'offer',\n        offer\n      }));\n    } else if (type === 'answer') {\n      const answer = await pcRef.current.createAnswer();\n      await pcRef.current.setLocalDescription(answer);\n      wsRef.current.send(JSON.stringify({\n        type: 'answer',\n        answer\n      }));\n    }\n  };\n  const handleSignal = async msg => {\n    switch (msg.type) {\n      case 'room-status':\n        setStatus(msg.peers === 2 ? 'connected' : 'waiting');\n        break;\n      case 'offer':\n        await pcRef.current.setRemoteDescription(msg.offer);\n        await negotiate('answer');\n        break;\n      case 'answer':\n        await pcRef.current.setRemoteDescription(msg.answer);\n        break;\n      case 'candidate':\n        msg.candidate && (await pcRef.current.addIceCandidate(msg.candidate));\n        break;\n      case 'end-call':\n        hangUp();\n        break;\n      case 'peer-left':\n        setStatus('peer-left');\n        break;\n      default:\n        break;\n    }\n  };\n  const sendMessage = text => {\n    var _dataChannelRef$curre;\n    if (((_dataChannelRef$curre = dataChannelRef.current) === null || _dataChannelRef$curre === void 0 ? void 0 : _dataChannelRef$curre.readyState) === 'open') {\n      dataChannelRef.current.send(text);\n      setChatMessages(c => [...c, {\n        sender: 'local',\n        text\n      }]);\n    }\n  };\n  const hangUp = () => {\n    var _localStreamRef$curre, _pcRef$current;\n    (_localStreamRef$curre = localStreamRef.current) === null || _localStreamRef$curre === void 0 ? void 0 : _localStreamRef$curre.getTracks().forEach(t => t.stop());\n    (_pcRef$current = pcRef.current) === null || _pcRef$current === void 0 ? void 0 : _pcRef$current.close();\n    wsRef.current.send(JSON.stringify({\n      type: 'end-call'\n    }));\n    wsRef.current.close();\n    setStatus('ended');\n  };\n  const cleanup = () => {\n    hangUp();\n  };\n  return {\n    status,\n    remoteStream,\n    chatMessages,\n    sendMessage,\n    isChannelOpen,\n    hangUp\n  };\n}\n_s(useWebRTC, \"0FAFKl6730g06Ls8nvcrzd0bNyc=\");","map":{"version":3,"names":["useEffect","useRef","useState","useWebRTC","callId","start","isInitiator","_s","status","setStatus","chatMessages","setChatMessages","isChannelOpen","setChannelOpen","remoteStream","setRemoteStream","MediaStream","wsRef","pcRef","dataChannelRef","localStreamRef","wsUrl","process","env","REACT_APP_WS_URL","REACT_APP_SERVER_URL","replace","current","WebSocket","onopen","initConnection","onmessage","data","handleSignal","JSON","parse","onerror","err","console","error","cleanup","RTCPeerConnection","iceServers","urls","REACT_APP_STUN_SERVER","REACT_APP_TURN_SERVER","username","REACT_APP_TURN_USER","credential","REACT_APP_TURN_PASS","onicecandidate","candidate","send","stringify","type","ontrack","track","prev","ns","getTracks","navigator","mediaDevices","getUserMedia","audio","echoCancellation","noiseSuppression","forEach","addTrack","createDataChannel","setupDataChannel","negotiate","ondatachannel","channel","dc","c","sender","text","onclose","offer","createOffer","setLocalDescription","answer","createAnswer","msg","peers","setRemoteDescription","addIceCandidate","hangUp","sendMessage","_dataChannelRef$curre","readyState","_localStreamRef$curre","_pcRef$current","t","stop","close"],"sources":["/Users/theodiamant/Desktop/webrtc/client/src/hooks/useWebRTC.js"],"sourcesContent":["// File: src/hooks/useWebRTC.js\nimport { useEffect, useRef, useState } from 'react';\n\nexport default function useWebRTC(callId, { start = true, isInitiator = false }) {\n  const [status, setStatus] = useState('idle');\n  const [chatMessages, setChatMessages] = useState([]);\n  const [isChannelOpen, setChannelOpen] = useState(false);\n  const [remoteStream, setRemoteStream] = useState(new MediaStream());\n\n  const wsRef = useRef(null);\n  const pcRef = useRef(null);\n  const dataChannelRef = useRef(null);\n  const localStreamRef = useRef(null);\n\n  useEffect(() => {\n    if (!start) return;\n    setStatus('connecting');\n    const wsUrl = `${process.env.REACT_APP_WS_URL || process.env.REACT_APP_SERVER_URL.replace(/^http/, 'ws')}?roomId=${callId}`;\n    wsRef.current = new WebSocket(wsUrl);\n\n    wsRef.current.onopen = () => initConnection();\n    wsRef.current.onmessage = ({ data }) => handleSignal(JSON.parse(data));\n    wsRef.current.onerror = (err) => console.error('WS error', err);\n\n    return cleanup;\n  }, [start]);\n\n  const initConnection = async () => {\n    pcRef.current = new RTCPeerConnection({\n      iceServers: [\n        { urls: process.env.REACT_APP_STUN_SERVER },\n        { urls: process.env.REACT_APP_TURN_SERVER, username: process.env.REACT_APP_TURN_USER, credential: process.env.REACT_APP_TURN_PASS }\n      ]\n    });\n\n    pcRef.current.onicecandidate = ({ candidate }) => {\n      if (candidate) wsRef.current.send(JSON.stringify({ type: 'candidate', candidate }));\n    };\n    pcRef.current.ontrack = ({ track }) => {\n      setRemoteStream(prev => {\n        const ns = new MediaStream([...prev.getTracks(), track]);\n        return ns;\n      });\n    };\n\n    localStreamRef.current = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true } });\n    localStreamRef.current.getTracks().forEach(track => pcRef.current.addTrack(track, localStreamRef.current));\n\n    if (isInitiator) {\n      dataChannelRef.current = pcRef.current.createDataChannel('chat');\n      setupDataChannel();\n      await negotiate('offer');\n    } else {\n      pcRef.current.ondatachannel = ({ channel }) => { dataChannelRef.current = channel; setupDataChannel(); };\n    }\n  };\n\n  const setupDataChannel = () => {\n    const dc = dataChannelRef.current;\n    dc.onopen = () => setChannelOpen(true);\n    dc.onmessage = ({ data }) => setChatMessages(c => [...c, { sender: 'remote', text: data }]);\n    dc.onclose = () => setChannelOpen(false);\n  };\n\n  const negotiate = async (type) => {\n    if (type === 'offer') {\n      const offer = await pcRef.current.createOffer();\n      await pcRef.current.setLocalDescription(offer);\n      wsRef.current.send(JSON.stringify({ type: 'offer', offer }));\n    } else if (type === 'answer') {\n      const answer = await pcRef.current.createAnswer();\n      await pcRef.current.setLocalDescription(answer);\n      wsRef.current.send(JSON.stringify({ type: 'answer', answer }));\n    }\n  };\n\n  const handleSignal = async (msg) => {\n    switch (msg.type) {\n      case 'room-status': setStatus(msg.peers === 2 ? 'connected' : 'waiting'); break;\n      case 'offer': await pcRef.current.setRemoteDescription(msg.offer); await negotiate('answer'); break;\n      case 'answer': await pcRef.current.setRemoteDescription(msg.answer); break;\n      case 'candidate': msg.candidate && await pcRef.current.addIceCandidate(msg.candidate); break;\n      case 'end-call': hangUp(); break;\n      case 'peer-left': setStatus('peer-left'); break;\n      default: break;\n    }\n  };\n\n  const sendMessage = (text) => {\n    if (dataChannelRef.current?.readyState === 'open') {\n      dataChannelRef.current.send(text);\n      setChatMessages(c => [...c, { sender: 'local', text }]);\n    }\n  };\n\n  const hangUp = () => {\n    localStreamRef.current?.getTracks().forEach(t => t.stop());\n    pcRef.current?.close();\n    wsRef.current.send(JSON.stringify({ type: 'end-call' }));\n    wsRef.current.close();\n    setStatus('ended');\n  };\n\n  const cleanup = () => { hangUp(); };\n\n  return { status, remoteStream, chatMessages, sendMessage, isChannelOpen, hangUp };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"var _s = $RefreshSig$();\n// src/hooks/useWebRTC.js\nimport { useEffect, useRef, useState } from \"react\";\nexport default function useWebRTC(callId, {\n  start = true,\n  isInitiator = false\n}) {\n  _s();\n  const [status, setStatus] = useState(\"waiting\"); // waiting → connecting → connected → ended\n  const wsRef = useRef(null);\n  const pcRef = useRef(null);\n  const dcRef = useRef(null);\n  const localStreamRef = useRef(null);\n  const remoteAudioRef = useRef(null);\n  const [chatMessages, setChatMessages] = useState([]);\n  const [isChannelOpen, setIsChannelOpen] = useState(false);\n\n  // 1) On monte le localStream une seule fois\n  useEffect(() => {\n    navigator.mediaDevices.getUserMedia({\n      audio: true\n    }).then(stream => {\n      localStreamRef.current = stream;\n    }).catch(err => {\n      console.error(\"Impossible d’accéder au micro :\", err);\n    });\n  }, []);\n\n  // 2) Signaling WebSocket\n  useEffect(() => {\n    if (!start) return;\n    const wsUrl = process.env.REACT_APP_SERVER_URL.replace(/^http/, \"ws\");\n    const ws = new WebSocket(`${wsUrl}?roomId=${callId}`);\n    wsRef.current = ws;\n    ws.onopen = () => console.log(\"WS ▶︎ open\");\n    ws.onmessage = async ({\n      data\n    }) => {\n      const msg = JSON.parse(data);\n      switch (msg.type) {\n        case \"room-status\":\n          if (msg.peers === 2 && status === \"waiting\") {\n            await startCall();\n          }\n          break;\n        case \"offer\":\n          await pcRef.current.setRemoteDescription(msg.offer);\n          await createAndSendAnswer();\n          break;\n        case \"answer\":\n          await pcRef.current.setRemoteDescription(msg.answer);\n          break;\n        case \"candidate\":\n          if (msg.candidate) {\n            await pcRef.current.addIceCandidate(msg.candidate);\n          }\n          break;\n        case \"end-call\":\n          hangUp();\n          break;\n      }\n    };\n    ws.onclose = () => console.log(\"WS ▶︎ closed\");\n    return () => {\n      var _pcRef$current;\n      ws.close();\n      (_pcRef$current = pcRef.current) === null || _pcRef$current === void 0 ? void 0 : _pcRef$current.close();\n    };\n  }, [callId, start, status]);\n\n  // 3) Création de la PeerConnection, échange SDP/ICE\n  async function startCall() {\n    setStatus(\"connecting\");\n    const pc = new RTCPeerConnection({\n      iceServers: [{\n        urls: process.env.REACT_APP_STUN_SERVER\n      }]\n    });\n    pcRef.current = pc;\n\n    // a) ICE candidates\n    pc.onicecandidate = ({\n      candidate\n    }) => {\n      if (candidate) {\n        wsRef.current.send(JSON.stringify({\n          type: \"candidate\",\n          candidate\n        }));\n      }\n    };\n\n    // b) réception de la piste distante\n    pc.ontrack = ({\n      streams: [stream]\n    }) => {\n      if (remoteAudioRef.current) {\n        remoteAudioRef.current.srcObject = stream;\n      }\n    };\n\n    // c) on ajoute le localStream dès qu’il est dispo\n    const localStream = localStreamRef.current;\n    if (localStream) {\n      localStream.getTracks().forEach(track => {\n        pc.addTrack(track, localStream);\n      });\n    }\n\n    // d) DataChannel pour le chat (uniquement si initiator)\n    if (isInitiator) {\n      const dc = pc.createDataChannel(\"chat\");\n      dcRef.current = dc;\n      setupDataChannel(dc);\n    } else {\n      pc.ondatachannel = ({\n        channel\n      }) => {\n        dcRef.current = channel;\n        setupDataChannel(channel);\n      };\n    }\n\n    // e) offer/answer\n    if (isInitiator) {\n      const offer = await pc.createOffer();\n      await pc.setLocalDescription(offer);\n      wsRef.current.send(JSON.stringify({\n        type: \"offer\",\n        offer\n      }));\n    }\n    setStatus(\"connected\");\n  }\n  async function createAndSendAnswer() {\n    const pc = pcRef.current;\n    const answer = await pc.createAnswer();\n    await pc.setLocalDescription(answer);\n    wsRef.current.send(JSON.stringify({\n      type: \"answer\",\n      answer\n    }));\n    setStatus(\"connected\");\n  }\n\n  // 4) DataChannel logic\n  function setupDataChannel(dc) {\n    dc.onopen = () => setIsChannelOpen(true);\n    dc.onclose = () => setIsChannelOpen(false);\n    dc.onmessage = ({\n      data\n    }) => setChatMessages(msgs => [...msgs, {\n      sender: \"peer\",\n      text: data\n    }]);\n  }\n  function sendMessage(text) {\n    var _dcRef$current;\n    setChatMessages(msgs => [...msgs, {\n      sender: \"local\",\n      text\n    }]);\n    if (((_dcRef$current = dcRef.current) === null || _dcRef$current === void 0 ? void 0 : _dcRef$current.readyState) === \"open\") {\n      dcRef.current.send(text);\n    }\n  }\n\n  // 5) commandes utilisateur\n  function toggleMute() {\n    var _localStreamRef$curre;\n    const track = (_localStreamRef$curre = localStreamRef.current) === null || _localStreamRef$curre === void 0 ? void 0 : _localStreamRef$curre.getAudioTracks()[0];\n    if (track) track.enabled = !track.enabled;\n  }\n  function hangUp() {\n    var _localStreamRef$curre2, _pcRef$current2;\n    setStatus(\"ended\");\n    (_localStreamRef$curre2 = localStreamRef.current) === null || _localStreamRef$curre2 === void 0 ? void 0 : _localStreamRef$curre2.getTracks().forEach(t => t.stop());\n    (_pcRef$current2 = pcRef.current) === null || _pcRef$current2 === void 0 ? void 0 : _pcRef$current2.close();\n    wsRef.current.send(JSON.stringify({\n      type: \"end-call\"\n    }));\n    wsRef.current.close();\n  }\n  return {\n    remoteAudioRef,\n    status,\n    chatMessages,\n    sendMessage,\n    toggleMute,\n    hangUp,\n    isChannelOpen\n  };\n}\n_s(useWebRTC, \"p5i2A/V4Uu+rGENNHEA/ZQGSYOw=\");","map":{"version":3,"names":["useEffect","useRef","useState","useWebRTC","callId","start","isInitiator","_s","status","setStatus","wsRef","pcRef","dcRef","localStreamRef","remoteAudioRef","chatMessages","setChatMessages","isChannelOpen","setIsChannelOpen","navigator","mediaDevices","getUserMedia","audio","then","stream","current","catch","err","console","error","wsUrl","process","env","REACT_APP_SERVER_URL","replace","ws","WebSocket","onopen","log","onmessage","data","msg","JSON","parse","type","peers","startCall","setRemoteDescription","offer","createAndSendAnswer","answer","candidate","addIceCandidate","hangUp","onclose","_pcRef$current","close","pc","RTCPeerConnection","iceServers","urls","REACT_APP_STUN_SERVER","onicecandidate","send","stringify","ontrack","streams","srcObject","localStream","getTracks","forEach","track","addTrack","dc","createDataChannel","setupDataChannel","ondatachannel","channel","createOffer","setLocalDescription","createAnswer","msgs","sender","text","sendMessage","_dcRef$current","readyState","toggleMute","_localStreamRef$curre","getAudioTracks","enabled","_localStreamRef$curre2","_pcRef$current2","t","stop"],"sources":["/Users/theodiamant/Desktop/webrtc/client/src/hooks/useWebRTC.js"],"sourcesContent":["// src/hooks/useWebRTC.js\nimport { useEffect, useRef, useState } from \"react\";\n\nexport default function useWebRTC(callId, { start = true, isInitiator = false }) {\n  const [status, setStatus] = useState(\"waiting\"); // waiting → connecting → connected → ended\n  const wsRef = useRef(null);\n  const pcRef = useRef(null);\n  const dcRef = useRef(null);\n  const localStreamRef = useRef(null);\n  const remoteAudioRef = useRef(null);\n  const [chatMessages, setChatMessages] = useState([]);\n  const [isChannelOpen, setIsChannelOpen] = useState(false);\n\n  // 1) On monte le localStream une seule fois\n  useEffect(() => {\n    navigator.mediaDevices\n      .getUserMedia({ audio: true })\n      .then((stream) => {\n        localStreamRef.current = stream;\n      })\n      .catch((err) => {\n        console.error(\"Impossible d’accéder au micro :\", err);\n      });\n  }, []);\n\n  // 2) Signaling WebSocket\n  useEffect(() => {\n    if (!start) return;\n    const wsUrl = process.env.REACT_APP_SERVER_URL.replace(/^http/, \"ws\");\n    const ws = new WebSocket(`${wsUrl}?roomId=${callId}`);\n    wsRef.current = ws;\n\n    ws.onopen = () => console.log(\"WS ▶︎ open\");\n    ws.onmessage = async ({ data }) => {\n      const msg = JSON.parse(data);\n      switch (msg.type) {\n        case \"room-status\":\n          if (msg.peers === 2 && status === \"waiting\") {\n            await startCall();\n          }\n          break;\n        case \"offer\":\n          await pcRef.current.setRemoteDescription(msg.offer);\n          await createAndSendAnswer();\n          break;\n        case \"answer\":\n          await pcRef.current.setRemoteDescription(msg.answer);\n          break;\n        case \"candidate\":\n          if (msg.candidate) {\n            await pcRef.current.addIceCandidate(msg.candidate);\n          }\n          break;\n        case \"end-call\":\n          hangUp();\n          break;\n      }\n    };\n    ws.onclose = () => console.log(\"WS ▶︎ closed\");\n\n    return () => {\n      ws.close();\n      pcRef.current?.close();\n    };\n  }, [callId, start, status]);\n\n  // 3) Création de la PeerConnection, échange SDP/ICE\n  async function startCall() {\n    setStatus(\"connecting\");\n    const pc = new RTCPeerConnection({\n      iceServers: [{ urls: process.env.REACT_APP_STUN_SERVER }],\n    });\n    pcRef.current = pc;\n\n    // a) ICE candidates\n    pc.onicecandidate = ({ candidate }) => {\n      if (candidate) {\n        wsRef.current.send(JSON.stringify({ type: \"candidate\", candidate }));\n      }\n    };\n\n    // b) réception de la piste distante\n    pc.ontrack = ({ streams: [stream] }) => {\n      if (remoteAudioRef.current) {\n        remoteAudioRef.current.srcObject = stream;\n      }\n    };\n\n    // c) on ajoute le localStream dès qu’il est dispo\n    const localStream = localStreamRef.current;\n    if (localStream) {\n      localStream.getTracks().forEach((track) => {\n        pc.addTrack(track, localStream);\n      });\n    }\n\n    // d) DataChannel pour le chat (uniquement si initiator)\n    if (isInitiator) {\n      const dc = pc.createDataChannel(\"chat\");\n      dcRef.current = dc;\n      setupDataChannel(dc);\n    } else {\n      pc.ondatachannel = ({ channel }) => {\n        dcRef.current = channel;\n        setupDataChannel(channel);\n      };\n    }\n\n    // e) offer/answer\n    if (isInitiator) {\n      const offer = await pc.createOffer();\n      await pc.setLocalDescription(offer);\n      wsRef.current.send(JSON.stringify({ type: \"offer\", offer }));\n    }\n\n    setStatus(\"connected\");\n  }\n\n  async function createAndSendAnswer() {\n    const pc = pcRef.current;\n    const answer = await pc.createAnswer();\n    await pc.setLocalDescription(answer);\n    wsRef.current.send(JSON.stringify({ type: \"answer\", answer }));\n    setStatus(\"connected\");\n  }\n\n  // 4) DataChannel logic\n  function setupDataChannel(dc) {\n    dc.onopen = () => setIsChannelOpen(true);\n    dc.onclose = () => setIsChannelOpen(false);\n    dc.onmessage = ({ data }) =>\n      setChatMessages((msgs) => [...msgs, { sender: \"peer\", text: data }]);\n  }\n\n  function sendMessage(text) {\n    setChatMessages((msgs) => [...msgs, { sender: \"local\", text }]);\n    if (dcRef.current?.readyState === \"open\") {\n      dcRef.current.send(text);\n    }\n  }\n\n  // 5) commandes utilisateur\n  function toggleMute() {\n    const track = localStreamRef.current?.getAudioTracks()[0];\n    if (track) track.enabled = !track.enabled;\n  }\n\n  function hangUp() {\n    setStatus(\"ended\");\n    localStreamRef.current?.getTracks().forEach((t) => t.stop());\n    pcRef.current?.close();\n    wsRef.current.send(JSON.stringify({ type: \"end-call\" }));\n    wsRef.current.close();\n  }\n\n  return {\n    remoteAudioRef,\n    status,\n    chatMessages,\n    sendMessage,\n    toggleMute,\n    hangUp,\n    isChannelOpen,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
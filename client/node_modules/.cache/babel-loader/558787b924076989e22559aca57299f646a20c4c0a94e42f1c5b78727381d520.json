{"ast":null,"code":"var _s = $RefreshSig$();\n// src/hooks/useWebRTC.js\nimport { useEffect, useRef, useState } from \"react\";\nexport default function useWebRTC(callId, {\n  start = false,\n  isInitiator = false,\n  localStream = null\n}) {\n  _s();\n  const [status, setStatus] = useState(\"waiting\"); // waiting → connecting → connected → peer-left → ended\n  const wsRef = useRef(null);\n  const pcRef = useRef(null);\n  const dcRef = useRef(null);\n  const remoteAudioRef = useRef(null);\n  const [chatMessages, setChatMessages] = useState([]);\n  const [isChannelOpen, setIsChannelOpen] = useState(false);\n\n  // 1) Signaling WebSocket\n  useEffect(() => {\n    if (!start) return;\n    const ws = new WebSocket(process.env.REACT_APP_SERVER_URL.replace(/^http/, \"ws\") + `?roomId=${callId}`);\n    wsRef.current = ws;\n    ws.onopen = () => console.log(\"WS ▶︎ open\");\n    ws.onmessage = async ({\n      data\n    }) => {\n      const msg = JSON.parse(data);\n      switch (msg.type) {\n        case \"room-status\":\n          // Quand on a les deux et qu'on n'a pas encore démarré...\n          if (msg.peers === 2 && status === \"waiting\") {\n            await _startCall();\n          }\n          break;\n        case \"offer\":\n          await pcRef.current.setRemoteDescription(msg.offer);\n          await _createAndSendAnswer();\n          break;\n        case \"answer\":\n          await pcRef.current.setRemoteDescription(msg.answer);\n          break;\n        case \"candidate\":\n          if (msg.candidate) {\n            await pcRef.current.addIceCandidate(msg.candidate);\n          }\n          break;\n        case \"end-call\":\n          _hangUp();\n          break;\n      }\n    };\n    ws.onclose = () => console.log(\"WS ▶︎ closed\");\n    return () => {\n      var _pcRef$current;\n      ws.close();\n      (_pcRef$current = pcRef.current) === null || _pcRef$current === void 0 ? void 0 : _pcRef$current.close();\n    };\n    // On ne dépend pas de status ici pour ne pas recréer la WS\n  }, [callId, start, localStream]);\n\n  // 2) Création de la RTCPeerConnection + échange SDP/ICE\n  async function _startCall() {\n    if (!localStream) {\n      console.warn(\"pas de MediaStream prêt, impossible de démarrer\");\n      return;\n    }\n    setStatus(\"connecting\");\n    const pc = new RTCPeerConnection({\n      iceServers: [{\n        urls: process.env.REACT_APP_STUN_SERVER\n      }]\n    });\n    pcRef.current = pc;\n\n    // a) suivi du connectionState\n    pc.onconnectionstatechange = () => {\n      console.log(\"PC state →\", pc.connectionState);\n      if (pc.connectionState === \"connected\") setStatus(\"connected\");else if (pc.connectionState === \"disconnected\" || pc.connectionState === \"failed\") setStatus(\"peer-left\");else if (pc.connectionState === \"connecting\") setStatus(\"connecting\");\n    };\n\n    // b) ICE candidates\n    pc.onicecandidate = ({\n      candidate\n    }) => {\n      if (candidate) {\n        wsRef.current.send(JSON.stringify({\n          type: \"candidate\",\n          candidate\n        }));\n      }\n    };\n\n    // c) réception de l’audio distant\n    pc.ontrack = ({\n      streams: [stream]\n    }) => {\n      if (remoteAudioRef.current) {\n        remoteAudioRef.current.srcObject = stream;\n      }\n    };\n\n    // d) ajout des pistes locales\n    localStream.getTracks().forEach(track => {\n      pc.addTrack(track, localStream);\n    });\n\n    // e) DataChannel\n    if (isInitiator) {\n      const dc = pc.createDataChannel(\"chat\");\n      dcRef.current = dc;\n      _setupDataChannel(dc);\n    } else {\n      pc.ondatachannel = ({\n        channel\n      }) => {\n        dcRef.current = channel;\n        _setupDataChannel(channel);\n      };\n    }\n\n    // f) offer (si initiator)\n    if (isInitiator) {\n      const offer = await pc.createOffer();\n      await pc.setLocalDescription(offer);\n      wsRef.current.send(JSON.stringify({\n        type: \"offer\",\n        offer\n      }));\n    }\n  }\n  async function _createAndSendAnswer() {\n    const pc = pcRef.current;\n    const answer = await pc.createAnswer();\n    await pc.setLocalDescription(answer);\n    wsRef.current.send(JSON.stringify({\n      type: \"answer\",\n      answer\n    }));\n  }\n\n  // 3) Chat\n  function _setupDataChannel(dc) {\n    dc.onopen = () => setIsChannelOpen(true);\n    dc.onclose = () => setIsChannelOpen(false);\n    dc.onmessage = ({\n      data\n    }) => setChatMessages(m => [...m, {\n      sender: \"peer\",\n      text: data\n    }]);\n  }\n  function sendMessage(text) {\n    var _dcRef$current;\n    setChatMessages(m => [...m, {\n      sender: \"local\",\n      text\n    }]);\n    if (((_dcRef$current = dcRef.current) === null || _dcRef$current === void 0 ? void 0 : _dcRef$current.readyState) === \"open\") {\n      dcRef.current.send(text);\n    }\n  }\n\n  // 4) utilitaires\n  function toggleMute() {\n    const t = localStream === null || localStream === void 0 ? void 0 : localStream.getAudioTracks()[0];\n    if (t) t.enabled = !t;\n  }\n  function _hangUp() {\n    var _pcRef$current2;\n    setStatus(\"ended\");\n    localStream === null || localStream === void 0 ? void 0 : localStream.getTracks().forEach(t => t.stop());\n    (_pcRef$current2 = pcRef.current) === null || _pcRef$current2 === void 0 ? void 0 : _pcRef$current2.close();\n    wsRef.current.send(JSON.stringify({\n      type: \"end-call\"\n    }));\n    wsRef.current.close();\n  }\n  return {\n    remoteAudioRef,\n    status,\n    chatMessages,\n    sendMessage,\n    toggleMute,\n    hangUp: _hangUp,\n    isChannelOpen\n  };\n}\n_s(useWebRTC, \"354madGT3+ldu0l3WUNUyovFH4Q=\");","map":{"version":3,"names":["useEffect","useRef","useState","useWebRTC","callId","start","isInitiator","localStream","_s","status","setStatus","wsRef","pcRef","dcRef","remoteAudioRef","chatMessages","setChatMessages","isChannelOpen","setIsChannelOpen","ws","WebSocket","process","env","REACT_APP_SERVER_URL","replace","current","onopen","console","log","onmessage","data","msg","JSON","parse","type","peers","_startCall","setRemoteDescription","offer","_createAndSendAnswer","answer","candidate","addIceCandidate","_hangUp","onclose","_pcRef$current","close","warn","pc","RTCPeerConnection","iceServers","urls","REACT_APP_STUN_SERVER","onconnectionstatechange","connectionState","onicecandidate","send","stringify","ontrack","streams","stream","srcObject","getTracks","forEach","track","addTrack","dc","createDataChannel","_setupDataChannel","ondatachannel","channel","createOffer","setLocalDescription","createAnswer","m","sender","text","sendMessage","_dcRef$current","readyState","toggleMute","t","getAudioTracks","enabled","_pcRef$current2","stop","hangUp"],"sources":["/Users/theodiamant/Desktop/webrtc/client/src/hooks/useWebRTC.js"],"sourcesContent":["// src/hooks/useWebRTC.js\nimport { useEffect, useRef, useState } from \"react\";\n\nexport default function useWebRTC(\n  callId,\n  { start = false, isInitiator = false, localStream = null }\n) {\n  const [status, setStatus] = useState(\"waiting\"); // waiting → connecting → connected → peer-left → ended\n  const wsRef = useRef(null);\n  const pcRef = useRef(null);\n  const dcRef = useRef(null);\n  const remoteAudioRef = useRef(null);\n  const [chatMessages, setChatMessages] = useState([]);\n  const [isChannelOpen, setIsChannelOpen] = useState(false);\n\n  // 1) Signaling WebSocket\n  useEffect(() => {\n    if (!start) return;\n    const ws = new WebSocket(\n      process.env.REACT_APP_SERVER_URL.replace(/^http/, \"ws\") +\n        `?roomId=${callId}`\n    );\n    wsRef.current = ws;\n    ws.onopen = () => console.log(\"WS ▶︎ open\");\n    ws.onmessage = async ({ data }) => {\n      const msg = JSON.parse(data);\n      switch (msg.type) {\n        case \"room-status\":\n          // Quand on a les deux et qu'on n'a pas encore démarré...\n          if (msg.peers === 2 && status === \"waiting\") {\n            await _startCall();\n          }\n          break;\n        case \"offer\":\n          await pcRef.current.setRemoteDescription(msg.offer);\n          await _createAndSendAnswer();\n          break;\n        case \"answer\":\n          await pcRef.current.setRemoteDescription(msg.answer);\n          break;\n        case \"candidate\":\n          if (msg.candidate) {\n            await pcRef.current.addIceCandidate(msg.candidate);\n          }\n          break;\n        case \"end-call\":\n          _hangUp();\n          break;\n      }\n    };\n    ws.onclose = () => console.log(\"WS ▶︎ closed\");\n    return () => {\n      ws.close();\n      pcRef.current?.close();\n    };\n    // On ne dépend pas de status ici pour ne pas recréer la WS\n  }, [callId, start, localStream]);\n\n  // 2) Création de la RTCPeerConnection + échange SDP/ICE\n  async function _startCall() {\n    if (!localStream) {\n      console.warn(\"pas de MediaStream prêt, impossible de démarrer\");\n      return;\n    }\n\n    setStatus(\"connecting\");\n    const pc = new RTCPeerConnection({\n      iceServers: [{ urls: process.env.REACT_APP_STUN_SERVER }],\n    });\n    pcRef.current = pc;\n\n    // a) suivi du connectionState\n    pc.onconnectionstatechange = () => {\n      console.log(\"PC state →\", pc.connectionState);\n      if (pc.connectionState === \"connected\") setStatus(\"connected\");\n      else if (pc.connectionState === \"disconnected\" || pc.connectionState === \"failed\")\n        setStatus(\"peer-left\");\n      else if (pc.connectionState === \"connecting\") setStatus(\"connecting\");\n    };\n\n    // b) ICE candidates\n    pc.onicecandidate = ({ candidate }) => {\n      if (candidate) {\n        wsRef.current.send(JSON.stringify({ type: \"candidate\", candidate }));\n      }\n    };\n\n    // c) réception de l’audio distant\n    pc.ontrack = ({ streams: [stream] }) => {\n      if (remoteAudioRef.current) {\n        remoteAudioRef.current.srcObject = stream;\n      }\n    };\n\n    // d) ajout des pistes locales\n    localStream.getTracks().forEach((track) => {\n      pc.addTrack(track, localStream);\n    });\n\n    // e) DataChannel\n    if (isInitiator) {\n      const dc = pc.createDataChannel(\"chat\");\n      dcRef.current = dc;\n      _setupDataChannel(dc);\n    } else {\n      pc.ondatachannel = ({ channel }) => {\n        dcRef.current = channel;\n        _setupDataChannel(channel);\n      };\n    }\n\n    // f) offer (si initiator)\n    if (isInitiator) {\n      const offer = await pc.createOffer();\n      await pc.setLocalDescription(offer);\n      wsRef.current.send(JSON.stringify({ type: \"offer\", offer }));\n    }\n  }\n\n  async function _createAndSendAnswer() {\n    const pc = pcRef.current;\n    const answer = await pc.createAnswer();\n    await pc.setLocalDescription(answer);\n    wsRef.current.send(JSON.stringify({ type: \"answer\", answer }));\n  }\n\n  // 3) Chat\n  function _setupDataChannel(dc) {\n    dc.onopen = () => setIsChannelOpen(true);\n    dc.onclose = () => setIsChannelOpen(false);\n    dc.onmessage = ({ data }) =>\n      setChatMessages((m) => [...m, { sender: \"peer\", text: data }]);\n  }\n\n  function sendMessage(text) {\n    setChatMessages((m) => [...m, { sender: \"local\", text }]);\n    if (dcRef.current?.readyState === \"open\") {\n      dcRef.current.send(text);\n    }\n  }\n\n  // 4) utilitaires\n  function toggleMute() {\n    const t = localStream?.getAudioTracks()[0];\n    if (t) t.enabled = !t;\n  }\n\n  function _hangUp() {\n    setStatus(\"ended\");\n    localStream?.getTracks().forEach((t) => t.stop());\n    pcRef.current?.close();\n    wsRef.current.send(JSON.stringify({ type: \"end-call\" }));\n    wsRef.current.close();\n  }\n\n  return {\n    remoteAudioRef,\n    status,\n    chatMessages,\n    sendMessage,\n    toggleMute,\n    hangUp: _hangUp,\n    isChannelOpen,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
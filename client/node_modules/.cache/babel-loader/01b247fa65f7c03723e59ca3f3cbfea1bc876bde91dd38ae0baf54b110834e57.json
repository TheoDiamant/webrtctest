{"ast":null,"code":"var _s = $RefreshSig$();\n// src/hooks/useWebRTC.js\nimport { useEffect, useRef, useState } from \"react\";\nexport default function useWebRTC(callId, {\n  timeout = 30000,\n  start = true,\n  isInitiator = false\n}) {\n  _s();\n  const wsRef = useRef(null);\n  const pcRef = useRef(null);\n  const dataChannelRef = useRef(null);\n  const remoteAudioRef = useRef(null);\n  const localStreamRef = useRef(null);\n  const [status, setStatus] = useState(\"waiting\");\n  const statusRef = useRef(status);\n  useEffect(() => {\n    statusRef.current = status;\n  }, [status]);\n  const [chatMessages, setChatMessages] = useState([]);\n\n  // 1) Récupérer l’audio local au démarrage\n  useEffect(() => {\n    if (!start) return;\n    navigator.mediaDevices.getUserMedia({\n      audio: true\n    }).then(stream => {\n      localStreamRef.current = stream;\n      console.log(\"[WebRTC] getUserMedia OK\");\n      setStatus(\"waiting\");\n    }).catch(err => {\n      console.error(\"[WebRTC] getUserMedia ERR :\", err);\n      setStatus(\"error\");\n    });\n  }, [start]);\n\n  // 2) Ouvrir le WebSocket **dès que** le hook démarre, sans attendre le stream\n  useEffect(() => {\n    if (!start) return;\n    const serverUrl = process.env.REACT_APP_SERVER_URL || window.location.origin;\n    const wsUrl = `${serverUrl.replace(/^http/, \"ws\")}?roomId=${callId}`;\n    console.log(\"[WebRTC] Connexion WS →\", wsUrl);\n    const ws = new WebSocket(wsUrl);\n    wsRef.current = ws;\n    ws.onopen = () => console.log(\"[WebRTC] WS open\");\n    ws.onerror = e => console.error(\"[WebRTC] WS error\", e);\n    ws.onclose = () => console.log(\"[WebRTC] WS closed\");\n    ws.onmessage = async ({\n      data\n    }) => {\n      let msg;\n      try {\n        msg = JSON.parse(data);\n      } catch {\n        return;\n      }\n      console.log(\"[WebRTC] signal reçu :\", msg.type);\n      switch (msg.type) {\n        case \"room-status\":\n          // l’initiateur appelle quand il voit le second arriver\n          if (msg.peers === 2 && isInitiator && statusRef.current === \"waiting\") {\n            await initiateCall(true);\n          }\n          break;\n        case \"offer\":\n          if (!pcRef.current) await initiateCall(false);\n          await pcRef.current.setRemoteDescription(msg.offer);\n          const answer = await pcRef.current.createAnswer();\n          await pcRef.current.setLocalDescription(answer);\n          ws.send(JSON.stringify({\n            type: \"answer\",\n            answer\n          }));\n          break;\n        case \"answer\":\n          await pcRef.current.setRemoteDescription(msg.answer);\n          break;\n        case \"candidate\":\n          await pcRef.current.addIceCandidate(msg.candidate);\n          break;\n        case \"peer-left\":\n          setStatus(\"peer-left\");\n          break;\n        case \"call-ended\":\n          setStatus(\"ended\");\n          break;\n      }\n    };\n\n    // Timeout\n    const timer = setTimeout(() => {\n      if (statusRef.current !== \"connected\") setStatus(\"timeout\");\n    }, timeout);\n    return () => {\n      var _pcRef$current;\n      clearTimeout(timer);\n      ws.close();\n      (_pcRef$current = pcRef.current) === null || _pcRef$current === void 0 ? void 0 : _pcRef$current.close();\n    };\n  }, [callId, start, isInitiator]);\n\n  // 3) Création du PeerConnection + tracks + data-channel\n  async function initiateCall(offerer) {\n    console.log(\"[WebRTC] initCall, offerer=\", offerer);\n    setStatus(\"connecting\");\n\n    // assurez-vous que le localStream est dispo\n    if (!localStreamRef.current) {\n      console.error(\"[WebRTC] localStream introuvable\");\n      return;\n    }\n    const pc = new RTCPeerConnection({\n      iceServers: [{\n        urls: process.env.REACT_APP_STUN_SERVER || \"stun:stun.l.google.com:19302\"\n      }]\n    });\n    pcRef.current = pc;\n\n    // logs d’état\n    pc.oniceconnectionstatechange = () => console.log(\"[WebRTC] iceState=\", pc.iceConnectionState);\n    pc.onconnectionstatechange = () => console.log(\"[WebRTC] connState=\", pc.connectionState);\n\n    // tracks audio\n    localStreamRef.current.getTracks().forEach(t => pc.addTrack(t, localStreamRef.current));\n\n    // réception audio\n    pc.ontrack = ({\n      streams: [stream]\n    }) => {\n      console.log(\"[WebRTC] ontrack reçu\");\n      remoteAudioRef.current.srcObject = stream;\n      remoteAudioRef.current.play().then(() => {\n        console.log(\"[WebRTC] audio distant joué\");\n        setStatus(\"connected\");\n      }).catch(e => console.warn(\"[WebRTC] play ERR\", e));\n    };\n\n    // data-channel\n    if (offerer) {\n      dataChannelRef.current = pc.createDataChannel(\"chat\");\n      setupDataChannel();\n    } else {\n      pc.ondatachannel = ({\n        channel\n      }) => {\n        dataChannelRef.current = channel;\n        setupDataChannel();\n      };\n    }\n\n    // ice\n    pc.onicecandidate = ({\n      candidate\n    }) => {\n      if (candidate) wsRef.current.send(JSON.stringify({\n        type: \"candidate\",\n        candidate\n      }));\n    };\n\n    // offer/answer\n    if (offerer) {\n      const offer = await pc.createOffer();\n      await pc.setLocalDescription(offer);\n      wsRef.current.send(JSON.stringify({\n        type: \"offer\",\n        offer\n      }));\n    }\n  }\n  function setupDataChannel() {\n    const dc = dataChannelRef.current;\n    dc.onopen = () => console.log(\"[DataChannel] ouvert\");\n    dc.onerror = e => console.error(\"[DataChannel] ERR\", e);\n    dc.onmessage = ({\n      data\n    }) => {\n      console.log(\"[DataChannel] msg reçu\", data);\n      setChatMessages(prev => [...prev, {\n        sender: \"peer\",\n        text: data\n      }]);\n    };\n  }\n  function sendMessage(text) {\n    const dc = dataChannelRef.current;\n    if ((dc === null || dc === void 0 ? void 0 : dc.readyState) === \"open\") {\n      dc.send(text);\n      setChatMessages(prev => [...prev, {\n        sender: \"local\",\n        text\n      }]);\n    } else {\n      console.warn(\"[Chat] DataChannel pas prêt :\", dc === null || dc === void 0 ? void 0 : dc.readyState);\n    }\n  }\n  function toggleMute() {\n    var _localStreamRef$curre, _dataChannelRef$curre;\n    const t = (_localStreamRef$curre = localStreamRef.current) === null || _localStreamRef$curre === void 0 ? void 0 : _localStreamRef$curre.getAudioTracks()[0];\n    if (!t) return;\n    t.enabled = !t.enabled;\n    if (!isInitiator && ((_dataChannelRef$curre = dataChannelRef.current) === null || _dataChannelRef$curre === void 0 ? void 0 : _dataChannelRef$curre.readyState) === \"open\") {\n      dataChannelRef.current.send(JSON.stringify({\n        type: \"mute\",\n        muted: !t.enabled\n      }));\n    }\n  }\n  function hangUp() {\n    if (isInitiator) wsRef.current.send(JSON.stringify({\n      type: \"end-call\"\n    }));\n    setStatus(\"ended\");\n    localStreamRef.current.getTracks().forEach(t => t.stop());\n    remoteAudioRef.current.srcObject = null;\n    setTimeout(() => {\n      wsRef.current.close();\n      pcRef.current.close();\n    }, 100);\n  }\n  return {\n    remoteAudioRef,\n    status,\n    chatMessages,\n    sendMessage,\n    toggleMute,\n    hangUp\n  };\n}\n_s(useWebRTC, \"TLs/eNx9EYu18GUEJ6wRvlAKYhA=\");","map":{"version":3,"names":["useEffect","useRef","useState","useWebRTC","callId","timeout","start","isInitiator","_s","wsRef","pcRef","dataChannelRef","remoteAudioRef","localStreamRef","status","setStatus","statusRef","current","chatMessages","setChatMessages","navigator","mediaDevices","getUserMedia","audio","then","stream","console","log","catch","err","error","serverUrl","process","env","REACT_APP_SERVER_URL","window","location","origin","wsUrl","replace","ws","WebSocket","onopen","onerror","e","onclose","onmessage","data","msg","JSON","parse","type","peers","initiateCall","setRemoteDescription","offer","answer","createAnswer","setLocalDescription","send","stringify","addIceCandidate","candidate","timer","setTimeout","_pcRef$current","clearTimeout","close","offerer","pc","RTCPeerConnection","iceServers","urls","REACT_APP_STUN_SERVER","oniceconnectionstatechange","iceConnectionState","onconnectionstatechange","connectionState","getTracks","forEach","t","addTrack","ontrack","streams","srcObject","play","warn","createDataChannel","setupDataChannel","ondatachannel","channel","onicecandidate","createOffer","dc","prev","sender","text","sendMessage","readyState","toggleMute","_localStreamRef$curre","_dataChannelRef$curre","getAudioTracks","enabled","muted","hangUp","stop"],"sources":["/Users/theodiamant/Desktop/webrtc/client/src/hooks/useWebRTC.js"],"sourcesContent":["// src/hooks/useWebRTC.js\nimport { useEffect, useRef, useState } from \"react\";\n\nexport default function useWebRTC(callId, { timeout = 30000, start = true, isInitiator = false }) {\n  const wsRef = useRef(null);\n  const pcRef = useRef(null);\n  const dataChannelRef = useRef(null);\n  const remoteAudioRef = useRef(null);\n  const localStreamRef = useRef(null);\n\n  const [status, setStatus] = useState(\"waiting\");\n  const statusRef = useRef(status);\n  useEffect(() => { statusRef.current = status; }, [status]);\n\n  const [chatMessages, setChatMessages] = useState([]);\n\n  // 1) Récupérer l’audio local au démarrage\n  useEffect(() => {\n    if (!start) return;\n    navigator.mediaDevices.getUserMedia({ audio: true })\n      .then(stream => {\n        localStreamRef.current = stream;\n        console.log(\"[WebRTC] getUserMedia OK\");\n        setStatus(\"waiting\"); \n      })\n      .catch(err => {\n        console.error(\"[WebRTC] getUserMedia ERR :\", err);\n        setStatus(\"error\");\n      });\n  }, [start]);\n\n  // 2) Ouvrir le WebSocket **dès que** le hook démarre, sans attendre le stream\n  useEffect(() => {\n    if (!start) return;\n\n    const serverUrl = process.env.REACT_APP_SERVER_URL || window.location.origin;\n    const wsUrl = `${serverUrl.replace(/^http/, \"ws\")}?roomId=${callId}`;\n    console.log(\"[WebRTC] Connexion WS →\", wsUrl);\n\n    const ws = new WebSocket(wsUrl);\n    wsRef.current = ws;\n\n    ws.onopen = () => console.log(\"[WebRTC] WS open\");\n    ws.onerror = e => console.error(\"[WebRTC] WS error\", e);\n    ws.onclose = () => console.log(\"[WebRTC] WS closed\");\n\n    ws.onmessage = async ({ data }) => {\n      let msg;\n      try { msg = JSON.parse(data); }\n      catch { return; }\n\n      console.log(\"[WebRTC] signal reçu :\", msg.type);\n\n      switch (msg.type) {\n        case \"room-status\":\n          // l’initiateur appelle quand il voit le second arriver\n          if (msg.peers === 2 && isInitiator && statusRef.current === \"waiting\") {\n            await initiateCall(true);\n          }\n          break;\n        case \"offer\":\n          if (!pcRef.current) await initiateCall(false);\n          await pcRef.current.setRemoteDescription(msg.offer);\n          const answer = await pcRef.current.createAnswer();\n          await pcRef.current.setLocalDescription(answer);\n          ws.send(JSON.stringify({ type: \"answer\", answer }));\n          break;\n        case \"answer\":\n          await pcRef.current.setRemoteDescription(msg.answer);\n          break;\n        case \"candidate\":\n          await pcRef.current.addIceCandidate(msg.candidate);\n          break;\n        case \"peer-left\":\n          setStatus(\"peer-left\");\n          break;\n        case \"call-ended\":\n          setStatus(\"ended\");\n          break;\n      }\n    };\n\n    // Timeout\n    const timer = setTimeout(() => {\n      if (statusRef.current !== \"connected\") setStatus(\"timeout\");\n    }, timeout);\n\n    return () => {\n      clearTimeout(timer);\n      ws.close();\n      pcRef.current?.close();\n    };\n  }, [callId, start, isInitiator]);\n\n  // 3) Création du PeerConnection + tracks + data-channel\n  async function initiateCall(offerer) {\n    console.log(\"[WebRTC] initCall, offerer=\", offerer);\n    setStatus(\"connecting\");\n\n    // assurez-vous que le localStream est dispo\n    if (!localStreamRef.current) {\n      console.error(\"[WebRTC] localStream introuvable\");\n      return;\n    }\n\n    const pc = new RTCPeerConnection({\n      iceServers: [{ urls: process.env.REACT_APP_STUN_SERVER || \"stun:stun.l.google.com:19302\" }]\n    });\n    pcRef.current = pc;\n\n    // logs d’état\n    pc.oniceconnectionstatechange = () =>\n      console.log(\"[WebRTC] iceState=\", pc.iceConnectionState);\n    pc.onconnectionstatechange = () =>\n      console.log(\"[WebRTC] connState=\", pc.connectionState);\n\n    // tracks audio\n    localStreamRef.current.getTracks().forEach(t => pc.addTrack(t, localStreamRef.current));\n\n    // réception audio\n    pc.ontrack = ({ streams: [stream] }) => {\n      console.log(\"[WebRTC] ontrack reçu\");\n      remoteAudioRef.current.srcObject = stream;\n      remoteAudioRef.current.play().then(() => {\n        console.log(\"[WebRTC] audio distant joué\");\n        setStatus(\"connected\");\n      }).catch(e => console.warn(\"[WebRTC] play ERR\", e));\n    };\n\n    // data-channel\n    if (offerer) {\n      dataChannelRef.current = pc.createDataChannel(\"chat\");\n      setupDataChannel();\n    } else {\n      pc.ondatachannel = ({ channel }) => {\n        dataChannelRef.current = channel;\n        setupDataChannel();\n      };\n    }\n\n    // ice\n    pc.onicecandidate = ({ candidate }) => {\n      if (candidate) wsRef.current.send(JSON.stringify({ type: \"candidate\", candidate }));\n    };\n\n    // offer/answer\n    if (offerer) {\n      const offer = await pc.createOffer();\n      await pc.setLocalDescription(offer);\n      wsRef.current.send(JSON.stringify({ type: \"offer\", offer }));\n    }\n  }\n\n  function setupDataChannel() {\n    const dc = dataChannelRef.current;\n    dc.onopen = () => console.log(\"[DataChannel] ouvert\");\n    dc.onerror = e => console.error(\"[DataChannel] ERR\", e);\n    dc.onmessage = ({ data }) => {\n      console.log(\"[DataChannel] msg reçu\", data);\n      setChatMessages(prev => [...prev, { sender: \"peer\", text: data }]);\n    };\n  }\n\n  function sendMessage(text) {\n    const dc = dataChannelRef.current;\n    if (dc?.readyState === \"open\") {\n      dc.send(text);\n      setChatMessages(prev => [...prev, { sender: \"local\", text }]);\n    } else {\n      console.warn(\"[Chat] DataChannel pas prêt :\", dc?.readyState);\n    }\n  }\n\n  function toggleMute() {\n    const t = localStreamRef.current?.getAudioTracks()[0];\n    if (!t) return;\n    t.enabled = !t.enabled;\n    if (!isInitiator && dataChannelRef.current?.readyState === \"open\") {\n      dataChannelRef.current.send(JSON.stringify({ type: \"mute\", muted: !t.enabled }));\n    }\n  }\n\n  function hangUp() {\n    if (isInitiator) wsRef.current.send(JSON.stringify({ type: \"end-call\" }));\n    setStatus(\"ended\");\n    localStreamRef.current.getTracks().forEach(t => t.stop());\n    remoteAudioRef.current.srcObject = null;\n    setTimeout(() => {\n      wsRef.current.close();\n      pcRef.current.close();\n    }, 100);\n  }\n\n  return {\n    remoteAudioRef,\n    status,\n    chatMessages,\n    sendMessage,\n    toggleMute,\n    hangUp,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"var _s = $RefreshSig$();\n// src/hooks/useWebRTC.js\nimport { useEffect, useRef, useState } from \"react\";\nexport default function useWebRTC(callId, {\n  timeout = 30000,\n  start = true,\n  isInitiator = false\n}) {\n  _s();\n  const wsRef = useRef();\n  const pcRef = useRef();\n  const dataChannelRef = useRef();\n  const remoteAudioRef = useRef();\n  const localStreamRef = useRef();\n  const [status, setStatus] = useState(\"waiting\");\n  const [chatMessages, setChatMessages] = useState([]);\n  const [localSpeaking, setLocalSpeaking] = useState(false);\n  const [remoteSpeaking, setRemoteSpeaking] = useState(false);\n  const [remoteMuted, setRemoteMuted] = useState(false);\n  useEffect(() => {\n    if (!start) return;\n\n    // 1) Open WebSocket\n    const serverUrl = process.env.REACT_APP_SERVER_URL;\n    wsRef.current = new WebSocket(`${serverUrl.replace(/^http/, \"ws\")}?roomId=${callId}`);\n    wsRef.current.onopen = () => console.log(\"WS open\");\n    wsRef.current.onclose = () => console.log(\"WS closed\");\n\n    // 2) Handle incoming signaling\n    wsRef.current.onmessage = async ({\n      data\n    }) => {\n      const text = typeof data === \"string\" ? data : data.toString();\n      let msg;\n      try {\n        msg = JSON.parse(text);\n      } catch {\n        return;\n      }\n      switch (msg.type) {\n        case \"room-status\":\n          if (msg.peers === 2 && status === \"waiting\") {\n            await initiateCall(isInitiator);\n          }\n          break;\n        case \"offer\":\n          await pcRef.current.setRemoteDescription(msg.offer);\n          {\n            const answer = await pcRef.current.createAnswer();\n            await pcRef.current.setLocalDescription(answer);\n            wsRef.current.send(JSON.stringify({\n              type: \"answer\",\n              answer\n            }));\n          }\n          break;\n        case \"answer\":\n          await pcRef.current.setRemoteDescription(msg.answer);\n          break;\n        case \"candidate\":\n          await pcRef.current.addIceCandidate(msg.candidate);\n          break;\n        case \"peer-left\":\n          setStatus(\"peer-left\");\n          break;\n        case \"call-ended\":\n          setStatus(\"ended\");\n          break;\n      }\n    };\n\n    // 3) Initialize PeerConnection and media\n    async function initiateCall(isInitiator) {\n      setStatus(\"connecting\");\n      pcRef.current = new RTCPeerConnection({\n        iceServers: [{\n          urls: process.env.REACT_APP_STUN_SERVER\n        }]\n      });\n\n      // Local audio + speech detection\n      localStreamRef.current = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n      const audioCtxL = new (window.AudioContext || window.webkitAudioContext)();\n      const analyserL = audioCtxL.createAnalyser();\n      const srcL = audioCtxL.createMediaStreamSource(localStreamRef.current);\n      srcL.connect(analyserL);\n      analyserL.fftSize = 256;\n      const dataL = new Uint8Array(analyserL.frequencyBinCount);\n      function detectLocal() {\n        analyserL.getByteFrequencyData(dataL);\n        const avg = dataL.reduce((a, b) => a + b, 0) / dataL.length;\n        setLocalSpeaking(avg > 30);\n        requestAnimationFrame(detectLocal);\n      }\n      detectLocal();\n\n      // Send local tracks\n      localStreamRef.current.getTracks().forEach(t => pcRef.current.addTrack(t, localStreamRef.current));\n\n      // Remote audio + speech & mute detection\n      pcRef.current.ontrack = ({\n        streams: [stream]\n      }) => {\n        if (remoteAudioRef.current) remoteAudioRef.current.srcObject = stream;\n\n        // Mute/unmute events on the remote audio track\n        const remoteTrack = stream.getAudioTracks()[0];\n        if (remoteTrack) {\n          remoteTrack.onmute = () => setRemoteMuted(true);\n          remoteTrack.onunmute = () => setRemoteMuted(false);\n        }\n\n        // Speech detection\n        if (!remoteSpeaking) {\n          const audioCtxR = new (window.AudioContext || window.webkitAudioContext)();\n          const analyserR = audioCtxR.createAnalyser();\n          const srcR = audioCtxR.createMediaStreamSource(stream);\n          srcR.connect(analyserR);\n          analyserR.fftSize = 256;\n          const dataR = new Uint8Array(analyserR.frequencyBinCount);\n          function detectRemote() {\n            analyserR.getByteFrequencyData(dataR);\n            const avgR = dataR.reduce((a, b) => a + b, 0) / dataR.length;\n            setRemoteSpeaking(avgR > 30);\n            requestAnimationFrame(detectRemote);\n          }\n          detectRemote();\n        }\n      };\n\n      // Data channel\n      if (isInitiator) {\n        dataChannelRef.current = pcRef.current.createDataChannel(\"chat\");\n        setupDataChannel();\n      } else {\n        pcRef.current.ondatachannel = ({\n          channel\n        }) => {\n          dataChannelRef.current = channel;\n          setupDataChannel();\n        };\n      }\n\n      // ICE candidates\n      pcRef.current.onicecandidate = ({\n        candidate\n      }) => {\n        if (candidate) wsRef.current.send(JSON.stringify({\n          type: \"candidate\",\n          candidate\n        }));\n      };\n\n      // Offer/Answer\n      if (isInitiator) {\n        const offer = await pcRef.current.createOffer();\n        await pcRef.current.setLocalDescription(offer);\n        wsRef.current.send(JSON.stringify({\n          type: \"offer\",\n          offer\n        }));\n      }\n      setStatus(\"connected\");\n    }\n\n    // 4) Chat channel\n    function setupDataChannel() {\n      dataChannelRef.current.onopen = () => console.log(\"DataChannel open\");\n      dataChannelRef.current.onmessage = ({\n        data\n      }) => setChatMessages(prev => [...prev, {\n        sender: \"peer\",\n        text: data\n      }]);\n    }\n\n    // 5) Timeout fallback\n    const timer = setTimeout(() => {\n      if (status !== \"connected\") setStatus(\"timeout\");\n    }, timeout);\n    return () => {\n      var _wsRef$current, _pcRef$current;\n      clearTimeout(timer);\n      (_wsRef$current = wsRef.current) === null || _wsRef$current === void 0 ? void 0 : _wsRef$current.close();\n      (_pcRef$current = pcRef.current) === null || _pcRef$current === void 0 ? void 0 : _pcRef$current.close();\n    };\n  }, [callId, start, status, isInitiator]);\n\n  // Send a chat message\n  function sendMessage(text) {\n    var _dataChannelRef$curre;\n    if (((_dataChannelRef$curre = dataChannelRef.current) === null || _dataChannelRef$curre === void 0 ? void 0 : _dataChannelRef$curre.readyState) === \"open\") {\n      dataChannelRef.current.send(text);\n      setChatMessages(prev => [...prev, {\n        sender: \"local\",\n        text\n      }]);\n    }\n  }\n\n  // Toggle local mic\n  function toggleMute() {\n    var _localStreamRef$curre;\n    const track = (_localStreamRef$curre = localStreamRef.current) === null || _localStreamRef$curre === void 0 ? void 0 : _localStreamRef$curre.getAudioTracks()[0];\n    if (track) track.enabled = !track.enabled;\n  }\n\n  // Hang up / end call\n  function hangUp() {\n    var _localStreamRef$curre2;\n    if (isInitiator) {\n      wsRef.current.send(JSON.stringify({\n        type: \"end-call\"\n      }));\n    }\n    setStatus(\"ended\");\n    (_localStreamRef$curre2 = localStreamRef.current) === null || _localStreamRef$curre2 === void 0 ? void 0 : _localStreamRef$curre2.getTracks().forEach(t => t.stop());\n    if (remoteAudioRef.current) remoteAudioRef.current.srcObject = null;\n    setTimeout(() => {\n      var _wsRef$current2, _pcRef$current2;\n      (_wsRef$current2 = wsRef.current) === null || _wsRef$current2 === void 0 ? void 0 : _wsRef$current2.close();\n      (_pcRef$current2 = pcRef.current) === null || _pcRef$current2 === void 0 ? void 0 : _pcRef$current2.close();\n    }, 100);\n  }\n  return {\n    remoteAudioRef,\n    status,\n    chatMessages,\n    sendMessage,\n    toggleMute,\n    hangUp,\n    localSpeaking,\n    remoteSpeaking,\n    remoteMuted\n  };\n}\n_s(useWebRTC, \"4rgj1MF26aBb4YoG7Yy1K5d2F/U=\");","map":{"version":3,"names":["useEffect","useRef","useState","useWebRTC","callId","timeout","start","isInitiator","_s","wsRef","pcRef","dataChannelRef","remoteAudioRef","localStreamRef","status","setStatus","chatMessages","setChatMessages","localSpeaking","setLocalSpeaking","remoteSpeaking","setRemoteSpeaking","remoteMuted","setRemoteMuted","serverUrl","process","env","REACT_APP_SERVER_URL","current","WebSocket","replace","onopen","console","log","onclose","onmessage","data","text","toString","msg","JSON","parse","type","peers","initiateCall","setRemoteDescription","offer","answer","createAnswer","setLocalDescription","send","stringify","addIceCandidate","candidate","RTCPeerConnection","iceServers","urls","REACT_APP_STUN_SERVER","navigator","mediaDevices","getUserMedia","audio","audioCtxL","window","AudioContext","webkitAudioContext","analyserL","createAnalyser","srcL","createMediaStreamSource","connect","fftSize","dataL","Uint8Array","frequencyBinCount","detectLocal","getByteFrequencyData","avg","reduce","a","b","length","requestAnimationFrame","getTracks","forEach","t","addTrack","ontrack","streams","stream","srcObject","remoteTrack","getAudioTracks","onmute","onunmute","audioCtxR","analyserR","srcR","dataR","detectRemote","avgR","createDataChannel","setupDataChannel","ondatachannel","channel","onicecandidate","createOffer","prev","sender","timer","setTimeout","_wsRef$current","_pcRef$current","clearTimeout","close","sendMessage","_dataChannelRef$curre","readyState","toggleMute","_localStreamRef$curre","track","enabled","hangUp","_localStreamRef$curre2","stop","_wsRef$current2","_pcRef$current2"],"sources":["/Users/theodiamant/Desktop/webrtc/client/src/hooks/useWebRTC.js"],"sourcesContent":["// src/hooks/useWebRTC.js\nimport { useEffect, useRef, useState } from \"react\";\n\nexport default function useWebRTC(\n  callId,\n  { timeout = 30000, start = true, isInitiator = false }\n) {\n  const wsRef = useRef();\n  const pcRef = useRef();\n  const dataChannelRef = useRef();\n  const remoteAudioRef = useRef();\n  const localStreamRef = useRef();\n\n  const [status, setStatus] = useState(\"waiting\");\n  const [chatMessages, setChatMessages] = useState([]);\n  const [localSpeaking, setLocalSpeaking] = useState(false);\n  const [remoteSpeaking, setRemoteSpeaking] = useState(false);\n  const [remoteMuted, setRemoteMuted] = useState(false);\n\n  useEffect(() => {\n    if (!start) return;\n\n    // 1) Open WebSocket\n    const serverUrl = process.env.REACT_APP_SERVER_URL;\n    wsRef.current = new WebSocket(\n      `${serverUrl.replace(/^http/, \"ws\")}?roomId=${callId}`\n    );\n\n    wsRef.current.onopen = () => console.log(\"WS open\");\n    wsRef.current.onclose = () => console.log(\"WS closed\");\n\n    // 2) Handle incoming signaling\n    wsRef.current.onmessage = async ({ data }) => {\n      const text = typeof data === \"string\" ? data : data.toString();\n      let msg;\n      try {\n        msg = JSON.parse(text);\n      } catch {\n        return;\n      }\n\n      switch (msg.type) {\n        case \"room-status\":\n          if (msg.peers === 2 && status === \"waiting\") {\n            await initiateCall(isInitiator);\n          }\n          break;\n        case \"offer\":\n          await pcRef.current.setRemoteDescription(msg.offer);\n          {\n            const answer = await pcRef.current.createAnswer();\n            await pcRef.current.setLocalDescription(answer);\n            wsRef.current.send(JSON.stringify({ type: \"answer\", answer }));\n          }\n          break;\n        case \"answer\":\n          await pcRef.current.setRemoteDescription(msg.answer);\n          break;\n        case \"candidate\":\n          await pcRef.current.addIceCandidate(msg.candidate);\n          break;\n        case \"peer-left\":\n          setStatus(\"peer-left\");\n          break;\n        case \"call-ended\":\n          setStatus(\"ended\");\n          break;\n      }\n    };\n\n    // 3) Initialize PeerConnection and media\n    async function initiateCall(isInitiator) {\n      setStatus(\"connecting\");\n      pcRef.current = new RTCPeerConnection({\n        iceServers: [{ urls: process.env.REACT_APP_STUN_SERVER }],\n      });\n\n      // Local audio + speech detection\n      localStreamRef.current = await navigator.mediaDevices.getUserMedia({\n        audio: true,\n      });\n      const audioCtxL = new (window.AudioContext ||\n        window.webkitAudioContext)();\n      const analyserL = audioCtxL.createAnalyser();\n      const srcL = audioCtxL.createMediaStreamSource(localStreamRef.current);\n      srcL.connect(analyserL);\n      analyserL.fftSize = 256;\n      const dataL = new Uint8Array(analyserL.frequencyBinCount);\n      function detectLocal() {\n        analyserL.getByteFrequencyData(dataL);\n        const avg = dataL.reduce((a, b) => a + b, 0) / dataL.length;\n        setLocalSpeaking(avg > 30);\n        requestAnimationFrame(detectLocal);\n      }\n      detectLocal();\n\n      // Send local tracks\n      localStreamRef.current\n        .getTracks()\n        .forEach((t) => pcRef.current.addTrack(t, localStreamRef.current));\n\n      // Remote audio + speech & mute detection\n      pcRef.current.ontrack = ({ streams: [stream] }) => {\n        if (remoteAudioRef.current) remoteAudioRef.current.srcObject = stream;\n\n        // Mute/unmute events on the remote audio track\n        const remoteTrack = stream.getAudioTracks()[0];\n        if (remoteTrack) {\n          remoteTrack.onmute = () => setRemoteMuted(true);\n          remoteTrack.onunmute = () => setRemoteMuted(false);\n        }\n\n        // Speech detection\n        if (!remoteSpeaking) {\n          const audioCtxR = new (window.AudioContext ||\n            window.webkitAudioContext)();\n          const analyserR = audioCtxR.createAnalyser();\n          const srcR = audioCtxR.createMediaStreamSource(stream);\n          srcR.connect(analyserR);\n          analyserR.fftSize = 256;\n          const dataR = new Uint8Array(analyserR.frequencyBinCount);\n          function detectRemote() {\n            analyserR.getByteFrequencyData(dataR);\n            const avgR = dataR.reduce((a, b) => a + b, 0) / dataR.length;\n            setRemoteSpeaking(avgR > 30);\n            requestAnimationFrame(detectRemote);\n          }\n          detectRemote();\n        }\n      };\n\n      // Data channel\n      if (isInitiator) {\n        dataChannelRef.current = pcRef.current.createDataChannel(\"chat\");\n        setupDataChannel();\n      } else {\n        pcRef.current.ondatachannel = ({ channel }) => {\n          dataChannelRef.current = channel;\n          setupDataChannel();\n        };\n      }\n\n      // ICE candidates\n      pcRef.current.onicecandidate = ({ candidate }) => {\n        if (candidate)\n          wsRef.current.send(JSON.stringify({ type: \"candidate\", candidate }));\n      };\n\n      // Offer/Answer\n      if (isInitiator) {\n        const offer = await pcRef.current.createOffer();\n        await pcRef.current.setLocalDescription(offer);\n        wsRef.current.send(JSON.stringify({ type: \"offer\", offer }));\n      }\n\n      setStatus(\"connected\");\n    }\n\n    // 4) Chat channel\n    function setupDataChannel() {\n      dataChannelRef.current.onopen = () => console.log(\"DataChannel open\");\n      dataChannelRef.current.onmessage = ({ data }) =>\n        setChatMessages((prev) => [...prev, { sender: \"peer\", text: data }]);\n    }\n\n    // 5) Timeout fallback\n    const timer = setTimeout(() => {\n      if (status !== \"connected\") setStatus(\"timeout\");\n    }, timeout);\n\n    return () => {\n      clearTimeout(timer);\n      wsRef.current?.close();\n      pcRef.current?.close();\n    };\n  }, [callId, start, status, isInitiator]);\n\n  // Send a chat message\n  function sendMessage(text) {\n    if (dataChannelRef.current?.readyState === \"open\") {\n      dataChannelRef.current.send(text);\n      setChatMessages((prev) => [...prev, { sender: \"local\", text }]);\n    }\n  }\n\n  // Toggle local mic\n  function toggleMute() {\n    const track = localStreamRef.current?.getAudioTracks()[0];\n    if (track) track.enabled = !track.enabled;\n  }\n\n  // Hang up / end call\n  function hangUp() {\n    if (isInitiator) {\n      wsRef.current.send(JSON.stringify({ type: \"end-call\" }));\n    }\n    setStatus(\"ended\");\n    localStreamRef.current?.getTracks().forEach((t) => t.stop());\n    if (remoteAudioRef.current) remoteAudioRef.current.srcObject = null;\n    setTimeout(() => {\n      wsRef.current?.close();\n      pcRef.current?.close();\n    }, 100);\n  }\n\n  return {\n    remoteAudioRef,\n    status,\n    chatMessages,\n    sendMessage,\n    toggleMute,\n    hangUp,\n    localSpeaking,\n    remoteSpeaking,\n    remoteMuted,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
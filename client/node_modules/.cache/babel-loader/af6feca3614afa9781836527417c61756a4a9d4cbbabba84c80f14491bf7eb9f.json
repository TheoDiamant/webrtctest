{"ast":null,"code":"var _s = $RefreshSig$();\n// src/hooks/useWebRTC.js\nimport { useEffect, useRef, useState } from \"react\";\nexport default function useWebRTC(callId, {\n  start = true,\n  isInitiator = false\n}) {\n  _s();\n  const wsRef = useRef(null);\n  const pcRef = useRef(null);\n  const remoteAudioRef = useRef(null);\n  const localStreamRef = useRef(null);\n  const [status, setStatus] = useState(\"waiting\");\n  useEffect(() => {\n    if (!start) return;\n    const serverUrl = process.env.REACT_APP_SERVER_URL;\n    const ws = new WebSocket(`${serverUrl.replace(/^http/, \"ws\")}?roomId=${callId}`);\n    wsRef.current = ws;\n    ws.onopen = () => console.log(\"WebSocket connected\");\n    ws.onmessage = async event => {\n      const message = JSON.parse(event.data);\n      if (message.offer) {\n        await pcRef.current.setRemoteDescription(new RTCSessionDescription(message.offer));\n        const answer = await pcRef.current.createAnswer();\n        await pcRef.current.setLocalDescription(answer);\n        ws.send(JSON.stringify({\n          answer\n        }));\n      } else if (message.answer) {\n        await pcRef.current.setRemoteDescription(new RTCSessionDescription(message.answer));\n      } else if (message.candidate) {\n        await pcRef.current.addIceCandidate(new RTCIceCandidate(message.candidate));\n      }\n    };\n    ws.onclose = () => console.log(\"WebSocket closed\");\n    startConnection();\n    return () => {\n      var _pcRef$current, _localStreamRef$curre;\n      ws.close();\n      (_pcRef$current = pcRef.current) === null || _pcRef$current === void 0 ? void 0 : _pcRef$current.close();\n      (_localStreamRef$curre = localStreamRef.current) === null || _localStreamRef$curre === void 0 ? void 0 : _localStreamRef$curre.getTracks().forEach(track => track.stop());\n    };\n  }, [start, callId, isInitiator]);\n  async function startConnection() {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      audio: true\n    });\n    localStreamRef.current = stream;\n    const pc = new RTCPeerConnection({\n      iceServers: [{\n        urls: process.env.REACT_APP_STUN_SERVER\n      }]\n    });\n    pcRef.current = pc;\n    stream.getTracks().forEach(track => pc.addTrack(track, stream));\n    pc.onicecandidate = event => {\n      if (event.candidate) {\n        wsRef.current.send(JSON.stringify({\n          candidate: event.candidate\n        }));\n      }\n    };\n    pc.ontrack = event => {\n      if (remoteAudioRef.current) {\n        remoteAudioRef.current.srcObject = event.streams[0];\n        remoteAudioRef.current.play().catch(e => console.log(\"play() error\", e));\n      }\n    };\n    if (isInitiator) {\n      const offer = await pc.createOffer();\n      await pc.setLocalDescription(offer);\n      wsRef.current.send(JSON.stringify({\n        offer\n      }));\n    }\n    setStatus(\"connected\");\n  }\n  return {\n    remoteAudioRef,\n    status\n  };\n}\n_s(useWebRTC, \"SV1IL/chJsMKc6zyrMS7EwdFw2Q=\");","map":{"version":3,"names":["useEffect","useRef","useState","useWebRTC","callId","start","isInitiator","_s","wsRef","pcRef","remoteAudioRef","localStreamRef","status","setStatus","serverUrl","process","env","REACT_APP_SERVER_URL","ws","WebSocket","replace","current","onopen","console","log","onmessage","event","message","JSON","parse","data","offer","setRemoteDescription","RTCSessionDescription","answer","createAnswer","setLocalDescription","send","stringify","candidate","addIceCandidate","RTCIceCandidate","onclose","startConnection","_pcRef$current","_localStreamRef$curre","close","getTracks","forEach","track","stop","stream","navigator","mediaDevices","getUserMedia","audio","pc","RTCPeerConnection","iceServers","urls","REACT_APP_STUN_SERVER","addTrack","onicecandidate","ontrack","srcObject","streams","play","catch","e","createOffer"],"sources":["/Users/theodiamant/Desktop/webrtc/client/src/hooks/useWebRTC.js"],"sourcesContent":["// src/hooks/useWebRTC.js\nimport { useEffect, useRef, useState } from \"react\";\n\nexport default function useWebRTC(callId, { start = true, isInitiator = false }) {\n  const wsRef = useRef(null);\n  const pcRef = useRef(null);\n  const remoteAudioRef = useRef(null);\n  const localStreamRef = useRef(null);\n\n  const [status, setStatus] = useState(\"waiting\");\n\n  useEffect(() => {\n    if (!start) return;\n\n    const serverUrl = process.env.REACT_APP_SERVER_URL;\n    const ws = new WebSocket(`${serverUrl.replace(/^http/, \"ws\")}?roomId=${callId}`);\n    wsRef.current = ws;\n\n    ws.onopen = () => console.log(\"WebSocket connected\");\n    ws.onmessage = async (event) => {\n      const message = JSON.parse(event.data);\n\n      if (message.offer) {\n        await pcRef.current.setRemoteDescription(new RTCSessionDescription(message.offer));\n        const answer = await pcRef.current.createAnswer();\n        await pcRef.current.setLocalDescription(answer);\n        ws.send(JSON.stringify({ answer }));\n      } else if (message.answer) {\n        await pcRef.current.setRemoteDescription(new RTCSessionDescription(message.answer));\n      } else if (message.candidate) {\n        await pcRef.current.addIceCandidate(new RTCIceCandidate(message.candidate));\n      }\n    };\n\n    ws.onclose = () => console.log(\"WebSocket closed\");\n\n    startConnection();\n\n    return () => {\n      ws.close();\n      pcRef.current?.close();\n      localStreamRef.current?.getTracks().forEach(track => track.stop());\n    };\n  }, [start, callId, isInitiator]);\n\n  async function startConnection() {\n    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n    localStreamRef.current = stream;\n\n    const pc = new RTCPeerConnection({ iceServers: [{ urls: process.env.REACT_APP_STUN_SERVER }] });\n    pcRef.current = pc;\n\n    stream.getTracks().forEach(track => pc.addTrack(track, stream));\n\n    pc.onicecandidate = (event) => {\n      if (event.candidate) {\n        wsRef.current.send(JSON.stringify({ candidate: event.candidate }));\n      }\n    };\n\n    pc.ontrack = (event) => {\n      if (remoteAudioRef.current) {\n        remoteAudioRef.current.srcObject = event.streams[0];\n        remoteAudioRef.current.play().catch(e => console.log(\"play() error\", e));\n      }\n    };\n\n    if (isInitiator) {\n      const offer = await pc.createOffer();\n      await pc.setLocalDescription(offer);\n      wsRef.current.send(JSON.stringify({ offer }));\n    }\n\n    setStatus(\"connected\");\n  }\n\n  return { remoteAudioRef, status };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
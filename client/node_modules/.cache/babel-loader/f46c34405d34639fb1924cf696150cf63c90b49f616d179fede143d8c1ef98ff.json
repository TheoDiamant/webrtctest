{"ast":null,"code":"var _s = $RefreshSig$();\n// src/hooks/useWebRTC.js\nimport { useEffect, useRef, useState } from \"react\";\nexport default function useWebRTC(callId, {\n  timeout = 30000,\n  start = true,\n  isInitiator = false\n}) {\n  _s();\n  const [status, setStatus] = useState(\"waiting\");\n  const statusRef = useRef(status);\n  useEffect(() => {\n    statusRef.current = status;\n  }, [status]);\n  const wsRef = useRef();\n  const pcRef = useRef();\n  const dataChannelRef = useRef();\n  const remoteAudioRef = useRef();\n  const localStreamRef = useRef();\n  const [chatMessages, setChatMessages] = useState([]);\n  const [localSpeaking, setLocalSpeaking] = useState(false);\n  const [remoteSpeaking, setRemoteSpeaking] = useState(false);\n  const [remoteMuted, setRemoteMuted] = useState(false);\n  const [isChannelOpen, setIsChannelOpen] = useState(false);\n\n  // 1) Signaling via WebSocket\n  // 1) Signaling via WebSocket\n  useEffect(() => {\n    if (!start) return;\n    const serverUrl = process.env.REACT_APP_SERVER_URL;\n    wsRef.current = new WebSocket(`${serverUrl.replace(/^http/, \"ws\")}?roomId=${callId}`);\n    wsRef.current.onopen = () => console.log(\"%cWS open\", \"color:green;font-weight:bold;\", new Date());\n    wsRef.current.onclose = () => console.log(\"%cWS closed\", \"color:gray;font-weight:bold;\", new Date());\n    wsRef.current.onmessage = async ({\n      data\n    }) => {\n      // Blob → texte\n      let text = data instanceof Blob ? await data.text() : data;\n      console.log(\"%cWS ←\", \"color:purple;\", text);\n\n      // JSON.parse\n      let msg;\n      try {\n        msg = JSON.parse(text);\n      } catch {\n        console.warn(\"WS: message non JSON reçu\", text);\n        return;\n      }\n      console.log(\"%cSignal→\", \"color:blue;\", msg.type, msg);\n      switch (msg.type) {\n        case \"room-status\":\n          console.log(\"room-status:\", msg.peers);\n          if (msg.peers === 1 && statusRef.current === \"connected\") {\n            var _pcRef$current;\n            console.log(\"Peer left → closing PC\");\n            setStatus(\"peer-left\");\n            (_pcRef$current = pcRef.current) === null || _pcRef$current === void 0 ? void 0 : _pcRef$current.close();\n            pcRef.current = null;\n            setIsChannelOpen(false);\n            if (remoteAudioRef.current) remoteAudioRef.current.srcObject = null;\n          } else if (msg.peers === 2 && statusRef.current !== \"connected\") {\n            console.log(\"Peer joined → restarting negotiation\");\n            setStatus(\"connecting\");\n            await initiateCall(isInitiator);\n          }\n          break;\n        case \"offer\":\n          console.log(\"received OFFER\", msg.offer);\n          await pcRef.current.setRemoteDescription(msg.offer);\n          // -- on force sendrecv sur l’audio, sinon l’answer peut être recvonly --\n          pcRef.current.getTransceivers().forEach(t => {\n            var _t$receiver$track;\n            if (((_t$receiver$track = t.receiver.track) === null || _t$receiver$track === void 0 ? void 0 : _t$receiver$track.kind) === \"audio\") {\n              t.direction = \"sendrecv\";\n            }\n          });\n          {\n            const answer = await pcRef.current.createAnswer();\n            await pcRef.current.setLocalDescription(answer);\n            wsRef.current.send(JSON.stringify({\n              type: \"answer\",\n              answer\n            }));\n          }\n          break;\n        case \"answer\":\n          console.log(\"received ANSWER\", msg.answer);\n          await pcRef.current.setRemoteDescription(msg.answer);\n          break;\n        case \"candidate\":\n          console.log(\"received CANDIDATE\", msg.candidate);\n          await pcRef.current.addIceCandidate(msg.candidate);\n          break;\n        case \"peer-left\":\n          console.log(\"peer-left\");\n          setStatus(\"peer-left\");\n          break;\n        case \"call-ended\":\n          console.log(\"call-ended\");\n          setStatus(\"ended\");\n          break;\n        default:\n          break;\n      }\n    };\n\n    // cleanup : on ferme juste les connexions\n    return () => {\n      var _wsRef$current, _pcRef$current2;\n      (_wsRef$current = wsRef.current) === null || _wsRef$current === void 0 ? void 0 : _wsRef$current.close();\n      (_pcRef$current2 = pcRef.current) === null || _pcRef$current2 === void 0 ? void 0 : _pcRef$current2.close();\n    };\n  }, [callId, start, isInitiator]);\n\n  // 2) WebRTC peer connection & media\n  async function initiateCall(isInitiator) {\n    console.log(\"%c⏱ initiateCall()\", \"color:orange;\", {\n      isInitiator\n    });\n    setStatus(\"connecting\");\n    pcRef.current = new RTCPeerConnection({\n      iceServers: [{\n        urls: process.env.REACT_APP_STUN_SERVER\n      }]\n    });\n    pcRef.current.onconnectionstatechange = () => console.log(\"PC connectionState:\", pcRef.current.connectionState);\n    pcRef.current.oniceconnectionstatechange = () => console.log(\"PC iceConnectionState:\", pcRef.current.iceConnectionState);\n\n    // 2.1) récupérer l’audio local\n    localStreamRef.current = await navigator.mediaDevices.getUserMedia({\n      audio: true\n    });\n    console.log(\"got localStream:\", localStreamRef.current);\n\n    // 2.2) détection de voix locale (animation)\n    const audioCtxL = new (window.AudioContext || window.webkitAudioContext)();\n    const analyserL = audioCtxL.createAnalyser();\n    const srcL = audioCtxL.createMediaStreamSource(localStreamRef.current);\n    srcL.connect(analyserL);\n    analyserL.fftSize = 256;\n    const dataL = new Uint8Array(analyserL.frequencyBinCount);\n    (function detectLocal() {\n      analyserL.getByteFrequencyData(dataL);\n      setLocalSpeaking(dataL.reduce((sum, v) => sum + v, 0) / dataL.length > 30);\n      requestAnimationFrame(detectLocal);\n    })();\n\n    // 2.3) ajout des pistes au PeerConnection\n    localStreamRef.current.getTracks().forEach(t => {\n      console.log(\"addTrack:\", t.kind);\n      pcRef.current.addTrack(t, localStreamRef.current);\n    });\n\n    // 2.4) réception et affichage de l’audio distant\n    pcRef.current.ontrack = ({\n      streams: [stream]\n    }) => {\n      console.log(\"%cPC ontrack →\", \"color:teal;\", stream);\n      if (remoteAudioRef.current) {\n        remoteAudioRef.current.srcObject = stream;\n      }\n      const rt = stream.getAudioTracks()[0];\n      if (rt) {\n        rt.onmute = () => setRemoteMuted(true);\n        rt.onunmute = () => setRemoteMuted(false);\n      }\n      if (!remoteSpeaking) {\n        const audioCtxR = new (window.AudioContext || window.webkitAudioContext)();\n        const analyserR = audioCtxR.createAnalyser();\n        const srcR = audioCtxR.createMediaStreamSource(stream);\n        srcR.connect(analyserR);\n        analyserR.fftSize = 256;\n        const dataR = new Uint8Array(analyserR.frequencyBinCount);\n        (function detectRemote() {\n          analyserR.getByteFrequencyData(dataR);\n          setRemoteSpeaking(dataR.reduce((sum, v) => sum + v, 0) / dataR.length > 30);\n          requestAnimationFrame(detectRemote);\n        })();\n      }\n    };\n\n    // 3) DataChannel pour le chat\n    if (isInitiator) {\n      console.log(\"creating DataChannel as initiator\");\n      dataChannelRef.current = pcRef.current.createDataChannel(\"chat\");\n      setupDataChannel();\n    } else {\n      pcRef.current.ondatachannel = ({\n        channel\n      }) => {\n        console.log(\"ondatachannel → received channel\", channel);\n        dataChannelRef.current = channel;\n        setupDataChannel();\n      };\n    }\n\n    // 4) échange ICE\n    pcRef.current.onicecandidate = ({\n      candidate\n    }) => {\n      console.log(\"onicecandidate → send\", candidate);\n      if (candidate) {\n        wsRef.current.send(JSON.stringify({\n          type: \"candidate\",\n          candidate\n        }));\n      }\n    };\n\n    // 5) negotiation offer/answer\n    if (isInitiator) {\n      const offer = await pcRef.current.createOffer();\n      console.log(\"created OFFER\", offer);\n      await pcRef.current.setLocalDescription(offer);\n      wsRef.current.send(JSON.stringify({\n        type: \"offer\",\n        offer\n      }));\n    }\n    setStatus(\"connected\");\n    console.log(\"status → connected\");\n  }\n  function setupDataChannel() {\n    dataChannelRef.current.onopen = () => {\n      console.log(\"%cDataChannel open\", \"color:green;\", dataChannelRef.current);\n      setIsChannelOpen(true);\n    };\n    dataChannelRef.current.onclose = () => {\n      console.log(\"%cDataChannel closed\", \"color:red;\", dataChannelRef.current);\n      setIsChannelOpen(false);\n    };\n    dataChannelRef.current.onmessage = ({\n      data\n    }) => {\n      console.log(\"%cDataChannel ← peer:\", \"color:purple;\", data);\n      setChatMessages(prev => [...prev, {\n        sender: \"peer\",\n        text: data\n      }]);\n    };\n  }\n\n  // Envoi d’un message (chat)\n  function sendMessage(text) {\n    var _dataChannelRef$curre, _dataChannelRef$curre2;\n    console.log(\"sendMessage() →\", text, \"DCstate:\", (_dataChannelRef$curre = dataChannelRef.current) === null || _dataChannelRef$curre === void 0 ? void 0 : _dataChannelRef$curre.readyState);\n    setChatMessages(prev => [...prev, {\n      sender: \"local\",\n      text\n    }]);\n    if (((_dataChannelRef$curre2 = dataChannelRef.current) === null || _dataChannelRef$curre2 === void 0 ? void 0 : _dataChannelRef$curre2.readyState) === \"open\") {\n      dataChannelRef.current.send(text);\n    } else {\n      console.warn(\"DataChannel pas open, message pas envoyé au pair :\", text);\n    }\n  }\n  function toggleMute() {\n    var _localStreamRef$curre;\n    const t = (_localStreamRef$curre = localStreamRef.current) === null || _localStreamRef$curre === void 0 ? void 0 : _localStreamRef$curre.getAudioTracks()[0];\n    if (t) t.enabled = !t;\n  }\n  function hangUp() {\n    var _localStreamRef$curre2;\n    if (isInitiator) {\n      wsRef.current.send(JSON.stringify({\n        type: \"end-call\"\n      }));\n    }\n    console.log(\"hangUp()\");\n    setStatus(\"ended\");\n    (_localStreamRef$curre2 = localStreamRef.current) === null || _localStreamRef$curre2 === void 0 ? void 0 : _localStreamRef$curre2.getTracks().forEach(t => t.stop());\n    if (remoteAudioRef.current) remoteAudioRef.current.srcObject = null;\n    setTimeout(() => {\n      var _wsRef$current2, _pcRef$current3;\n      (_wsRef$current2 = wsRef.current) === null || _wsRef$current2 === void 0 ? void 0 : _wsRef$current2.close();\n      (_pcRef$current3 = pcRef.current) === null || _pcRef$current3 === void 0 ? void 0 : _pcRef$current3.close();\n    }, 100);\n  }\n  return {\n    remoteAudioRef,\n    status,\n    chatMessages,\n    sendMessage,\n    toggleMute,\n    hangUp,\n    localSpeaking,\n    remoteSpeaking,\n    remoteMuted,\n    isChannelOpen\n  };\n}\n_s(useWebRTC, \"57q8djH89EADKyJ4WZAcEuUFvQc=\");","map":{"version":3,"names":["useEffect","useRef","useState","useWebRTC","callId","timeout","start","isInitiator","_s","status","setStatus","statusRef","current","wsRef","pcRef","dataChannelRef","remoteAudioRef","localStreamRef","chatMessages","setChatMessages","localSpeaking","setLocalSpeaking","remoteSpeaking","setRemoteSpeaking","remoteMuted","setRemoteMuted","isChannelOpen","setIsChannelOpen","serverUrl","process","env","REACT_APP_SERVER_URL","WebSocket","replace","onopen","console","log","Date","onclose","onmessage","data","text","Blob","msg","JSON","parse","warn","type","peers","_pcRef$current","close","srcObject","initiateCall","offer","setRemoteDescription","getTransceivers","forEach","t","_t$receiver$track","receiver","track","kind","direction","answer","createAnswer","setLocalDescription","send","stringify","candidate","addIceCandidate","_wsRef$current","_pcRef$current2","RTCPeerConnection","iceServers","urls","REACT_APP_STUN_SERVER","onconnectionstatechange","connectionState","oniceconnectionstatechange","iceConnectionState","navigator","mediaDevices","getUserMedia","audio","audioCtxL","window","AudioContext","webkitAudioContext","analyserL","createAnalyser","srcL","createMediaStreamSource","connect","fftSize","dataL","Uint8Array","frequencyBinCount","detectLocal","getByteFrequencyData","reduce","sum","v","length","requestAnimationFrame","getTracks","addTrack","ontrack","streams","stream","rt","getAudioTracks","onmute","onunmute","audioCtxR","analyserR","srcR","dataR","detectRemote","createDataChannel","setupDataChannel","ondatachannel","channel","onicecandidate","createOffer","prev","sender","sendMessage","_dataChannelRef$curre","_dataChannelRef$curre2","readyState","toggleMute","_localStreamRef$curre","enabled","hangUp","_localStreamRef$curre2","stop","setTimeout","_wsRef$current2","_pcRef$current3"],"sources":["/Users/theodiamant/Desktop/webrtc/client/src/hooks/useWebRTC.js"],"sourcesContent":["// src/hooks/useWebRTC.js\nimport { useEffect, useRef, useState } from \"react\";\n\nexport default function useWebRTC(\n  callId,\n  { timeout = 30000, start = true, isInitiator = false }\n) {\n  const [status, setStatus] = useState(\"waiting\");\n  const statusRef = useRef(status);\n  useEffect(() => {\n    statusRef.current = status;\n  }, [status]);\n\n  const wsRef = useRef();\n  const pcRef = useRef();\n  const dataChannelRef = useRef();\n  const remoteAudioRef = useRef();\n  const localStreamRef = useRef();\n\n  const [chatMessages, setChatMessages] = useState([]);\n  const [localSpeaking, setLocalSpeaking] = useState(false);\n  const [remoteSpeaking, setRemoteSpeaking] = useState(false);\n  const [remoteMuted, setRemoteMuted] = useState(false);\n  const [isChannelOpen, setIsChannelOpen] = useState(false);\n\n  // 1) Signaling via WebSocket\n  // 1) Signaling via WebSocket\n  useEffect(() => {\n    if (!start) return;\n\n    const serverUrl = process.env.REACT_APP_SERVER_URL;\n    wsRef.current = new WebSocket(\n      `${serverUrl.replace(/^http/, \"ws\")}?roomId=${callId}`\n    );\n    wsRef.current.onopen = () =>\n      console.log(\"%cWS open\", \"color:green;font-weight:bold;\", new Date());\n    wsRef.current.onclose = () =>\n      console.log(\"%cWS closed\", \"color:gray;font-weight:bold;\", new Date());\n\n    wsRef.current.onmessage = async ({ data }) => {\n      // Blob → texte\n      let text = data instanceof Blob ? await data.text() : data;\n      console.log(\"%cWS ←\", \"color:purple;\", text);\n\n      // JSON.parse\n      let msg;\n      try {\n        msg = JSON.parse(text);\n      } catch {\n        console.warn(\"WS: message non JSON reçu\", text);\n        return;\n      }\n      console.log(\"%cSignal→\", \"color:blue;\", msg.type, msg);\n\n      switch (msg.type) {\n        case \"room-status\":\n          console.log(\"room-status:\", msg.peers);\n          if (msg.peers === 1 && statusRef.current === \"connected\") {\n            console.log(\"Peer left → closing PC\");\n            setStatus(\"peer-left\");\n            pcRef.current?.close();\n            pcRef.current = null;\n            setIsChannelOpen(false);\n            if (remoteAudioRef.current) remoteAudioRef.current.srcObject = null;\n          } else if (msg.peers === 2 && statusRef.current !== \"connected\") {\n            console.log(\"Peer joined → restarting negotiation\");\n            setStatus(\"connecting\");\n            await initiateCall(isInitiator);\n          }\n          break;\n\n        case \"offer\":\n          console.log(\"received OFFER\", msg.offer);\n          await pcRef.current.setRemoteDescription(msg.offer);\n          // -- on force sendrecv sur l’audio, sinon l’answer peut être recvonly --\n          pcRef.current.getTransceivers().forEach((t) => {\n            if (t.receiver.track?.kind === \"audio\") {\n              t.direction = \"sendrecv\";\n            }\n          });\n          {\n            const answer = await pcRef.current.createAnswer();\n            await pcRef.current.setLocalDescription(answer);\n            wsRef.current.send(JSON.stringify({ type: \"answer\", answer }));\n          }\n          break;\n        case \"answer\":\n          console.log(\"received ANSWER\", msg.answer);\n          await pcRef.current.setRemoteDescription(msg.answer);\n          break;\n        case \"candidate\":\n          console.log(\"received CANDIDATE\", msg.candidate);\n          await pcRef.current.addIceCandidate(msg.candidate);\n          break;\n        case \"peer-left\":\n          console.log(\"peer-left\");\n          setStatus(\"peer-left\");\n          break;\n        case \"call-ended\":\n          console.log(\"call-ended\");\n          setStatus(\"ended\");\n          break;\n        default:\n          break;\n      }\n    };\n\n    // cleanup : on ferme juste les connexions\n    return () => {\n      wsRef.current?.close();\n      pcRef.current?.close();\n    };\n  }, [callId, start, isInitiator]);\n\n  // 2) WebRTC peer connection & media\n  async function initiateCall(isInitiator) {\n    console.log(\"%c⏱ initiateCall()\", \"color:orange;\", { isInitiator });\n    setStatus(\"connecting\");\n\n    pcRef.current = new RTCPeerConnection({\n      iceServers: [{ urls: process.env.REACT_APP_STUN_SERVER }],\n    });\n    pcRef.current.onconnectionstatechange = () =>\n      console.log(\"PC connectionState:\", pcRef.current.connectionState);\n    pcRef.current.oniceconnectionstatechange = () =>\n      console.log(\"PC iceConnectionState:\", pcRef.current.iceConnectionState);\n\n    // 2.1) récupérer l’audio local\n    localStreamRef.current = await navigator.mediaDevices.getUserMedia({\n      audio: true,\n    });\n    console.log(\"got localStream:\", localStreamRef.current);\n\n    // 2.2) détection de voix locale (animation)\n    const audioCtxL = new (window.AudioContext || window.webkitAudioContext)();\n    const analyserL = audioCtxL.createAnalyser();\n    const srcL = audioCtxL.createMediaStreamSource(localStreamRef.current);\n    srcL.connect(analyserL);\n    analyserL.fftSize = 256;\n    const dataL = new Uint8Array(analyserL.frequencyBinCount);\n    (function detectLocal() {\n      analyserL.getByteFrequencyData(dataL);\n      setLocalSpeaking(\n        dataL.reduce((sum, v) => sum + v, 0) / dataL.length > 30\n      );\n      requestAnimationFrame(detectLocal);\n    })();\n\n    // 2.3) ajout des pistes au PeerConnection\n    localStreamRef.current.getTracks().forEach((t) => {\n      console.log(\"addTrack:\", t.kind);\n      pcRef.current.addTrack(t, localStreamRef.current);\n    });\n\n    // 2.4) réception et affichage de l’audio distant\n    pcRef.current.ontrack = ({ streams: [stream] }) => {\n      console.log(\"%cPC ontrack →\", \"color:teal;\", stream);\n      if (remoteAudioRef.current) {\n        remoteAudioRef.current.srcObject = stream;\n      }\n\n      const rt = stream.getAudioTracks()[0];\n      if (rt) {\n        rt.onmute = () => setRemoteMuted(true);\n        rt.onunmute = () => setRemoteMuted(false);\n      }\n\n      if (!remoteSpeaking) {\n        const audioCtxR = new (window.AudioContext ||\n          window.webkitAudioContext)();\n        const analyserR = audioCtxR.createAnalyser();\n        const srcR = audioCtxR.createMediaStreamSource(stream);\n        srcR.connect(analyserR);\n        analyserR.fftSize = 256;\n        const dataR = new Uint8Array(analyserR.frequencyBinCount);\n        (function detectRemote() {\n          analyserR.getByteFrequencyData(dataR);\n          setRemoteSpeaking(\n            dataR.reduce((sum, v) => sum + v, 0) / dataR.length > 30\n          );\n          requestAnimationFrame(detectRemote);\n        })();\n      }\n    };\n\n    // 3) DataChannel pour le chat\n    if (isInitiator) {\n      console.log(\"creating DataChannel as initiator\");\n      dataChannelRef.current = pcRef.current.createDataChannel(\"chat\");\n      setupDataChannel();\n    } else {\n      pcRef.current.ondatachannel = ({ channel }) => {\n        console.log(\"ondatachannel → received channel\", channel);\n        dataChannelRef.current = channel;\n        setupDataChannel();\n      };\n    }\n\n    // 4) échange ICE\n    pcRef.current.onicecandidate = ({ candidate }) => {\n      console.log(\"onicecandidate → send\", candidate);\n      if (candidate) {\n        wsRef.current.send(JSON.stringify({ type: \"candidate\", candidate }));\n      }\n    };\n\n    // 5) negotiation offer/answer\n    if (isInitiator) {\n      const offer = await pcRef.current.createOffer();\n      console.log(\"created OFFER\", offer);\n      await pcRef.current.setLocalDescription(offer);\n      wsRef.current.send(JSON.stringify({ type: \"offer\", offer }));\n    }\n\n    setStatus(\"connected\");\n    console.log(\"status → connected\");\n  }\n\n  function setupDataChannel() {\n    dataChannelRef.current.onopen = () => {\n      console.log(\"%cDataChannel open\", \"color:green;\", dataChannelRef.current);\n      setIsChannelOpen(true);\n    };\n    dataChannelRef.current.onclose = () => {\n      console.log(\"%cDataChannel closed\", \"color:red;\", dataChannelRef.current);\n      setIsChannelOpen(false);\n    };\n    dataChannelRef.current.onmessage = ({ data }) => {\n      console.log(\"%cDataChannel ← peer:\", \"color:purple;\", data);\n      setChatMessages((prev) => [...prev, { sender: \"peer\", text: data }]);\n    };\n  }\n\n  // Envoi d’un message (chat)\n  function sendMessage(text) {\n    console.log(\n      \"sendMessage() →\",\n      text,\n      \"DCstate:\",\n      dataChannelRef.current?.readyState\n    );\n    setChatMessages((prev) => [...prev, { sender: \"local\", text }]);\n\n    if (dataChannelRef.current?.readyState === \"open\") {\n      dataChannelRef.current.send(text);\n    } else {\n      console.warn(\"DataChannel pas open, message pas envoyé au pair :\", text);\n    }\n  }\n\n  function toggleMute() {\n    const t = localStreamRef.current?.getAudioTracks()[0];\n    if (t) t.enabled = !t;\n  }\n\n  function hangUp() {\n    if (isInitiator) {\n      wsRef.current.send(JSON.stringify({ type: \"end-call\" }));\n    }\n    console.log(\"hangUp()\");\n    setStatus(\"ended\");\n    localStreamRef.current?.getTracks().forEach((t) => t.stop());\n    if (remoteAudioRef.current) remoteAudioRef.current.srcObject = null;\n    setTimeout(() => {\n      wsRef.current?.close();\n      pcRef.current?.close();\n    }, 100);\n  }\n\n  return {\n    remoteAudioRef,\n    status,\n    chatMessages,\n    sendMessage,\n    toggleMute,\n    hangUp,\n    localSpeaking,\n    remoteSpeaking,\n    remoteMuted,\n    isChannelOpen,\n  };\n}\n"],"mappings":";AAAA;AACA,SAASA,SAAS,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AAEnD,eAAe,SAASC,SAASA,CAC/BC,MAAM,EACN;EAAEC,OAAO,GAAG,KAAK;EAAEC,KAAK,GAAG,IAAI;EAAEC,WAAW,GAAG;AAAM,CAAC,EACtD;EAAAC,EAAA;EACA,MAAM,CAACC,MAAM,EAAEC,SAAS,CAAC,GAAGR,QAAQ,CAAC,SAAS,CAAC;EAC/C,MAAMS,SAAS,GAAGV,MAAM,CAACQ,MAAM,CAAC;EAChCT,SAAS,CAAC,MAAM;IACdW,SAAS,CAACC,OAAO,GAAGH,MAAM;EAC5B,CAAC,EAAE,CAACA,MAAM,CAAC,CAAC;EAEZ,MAAMI,KAAK,GAAGZ,MAAM,CAAC,CAAC;EACtB,MAAMa,KAAK,GAAGb,MAAM,CAAC,CAAC;EACtB,MAAMc,cAAc,GAAGd,MAAM,CAAC,CAAC;EAC/B,MAAMe,cAAc,GAAGf,MAAM,CAAC,CAAC;EAC/B,MAAMgB,cAAc,GAAGhB,MAAM,CAAC,CAAC;EAE/B,MAAM,CAACiB,YAAY,EAAEC,eAAe,CAAC,GAAGjB,QAAQ,CAAC,EAAE,CAAC;EACpD,MAAM,CAACkB,aAAa,EAAEC,gBAAgB,CAAC,GAAGnB,QAAQ,CAAC,KAAK,CAAC;EACzD,MAAM,CAACoB,cAAc,EAAEC,iBAAiB,CAAC,GAAGrB,QAAQ,CAAC,KAAK,CAAC;EAC3D,MAAM,CAACsB,WAAW,EAAEC,cAAc,CAAC,GAAGvB,QAAQ,CAAC,KAAK,CAAC;EACrD,MAAM,CAACwB,aAAa,EAAEC,gBAAgB,CAAC,GAAGzB,QAAQ,CAAC,KAAK,CAAC;;EAEzD;EACA;EACAF,SAAS,CAAC,MAAM;IACd,IAAI,CAACM,KAAK,EAAE;IAEZ,MAAMsB,SAAS,GAAGC,OAAO,CAACC,GAAG,CAACC,oBAAoB;IAClDlB,KAAK,CAACD,OAAO,GAAG,IAAIoB,SAAS,CAC3B,GAAGJ,SAAS,CAACK,OAAO,CAAC,OAAO,EAAE,IAAI,CAAC,WAAW7B,MAAM,EACtD,CAAC;IACDS,KAAK,CAACD,OAAO,CAACsB,MAAM,GAAG,MACrBC,OAAO,CAACC,GAAG,CAAC,WAAW,EAAE,+BAA+B,EAAE,IAAIC,IAAI,CAAC,CAAC,CAAC;IACvExB,KAAK,CAACD,OAAO,CAAC0B,OAAO,GAAG,MACtBH,OAAO,CAACC,GAAG,CAAC,aAAa,EAAE,8BAA8B,EAAE,IAAIC,IAAI,CAAC,CAAC,CAAC;IAExExB,KAAK,CAACD,OAAO,CAAC2B,SAAS,GAAG,OAAO;MAAEC;IAAK,CAAC,KAAK;MAC5C;MACA,IAAIC,IAAI,GAAGD,IAAI,YAAYE,IAAI,GAAG,MAAMF,IAAI,CAACC,IAAI,CAAC,CAAC,GAAGD,IAAI;MAC1DL,OAAO,CAACC,GAAG,CAAC,QAAQ,EAAE,eAAe,EAAEK,IAAI,CAAC;;MAE5C;MACA,IAAIE,GAAG;MACP,IAAI;QACFA,GAAG,GAAGC,IAAI,CAACC,KAAK,CAACJ,IAAI,CAAC;MACxB,CAAC,CAAC,MAAM;QACNN,OAAO,CAACW,IAAI,CAAC,2BAA2B,EAAEL,IAAI,CAAC;QAC/C;MACF;MACAN,OAAO,CAACC,GAAG,CAAC,WAAW,EAAE,aAAa,EAAEO,GAAG,CAACI,IAAI,EAAEJ,GAAG,CAAC;MAEtD,QAAQA,GAAG,CAACI,IAAI;QACd,KAAK,aAAa;UAChBZ,OAAO,CAACC,GAAG,CAAC,cAAc,EAAEO,GAAG,CAACK,KAAK,CAAC;UACtC,IAAIL,GAAG,CAACK,KAAK,KAAK,CAAC,IAAIrC,SAAS,CAACC,OAAO,KAAK,WAAW,EAAE;YAAA,IAAAqC,cAAA;YACxDd,OAAO,CAACC,GAAG,CAAC,wBAAwB,CAAC;YACrC1B,SAAS,CAAC,WAAW,CAAC;YACtB,CAAAuC,cAAA,GAAAnC,KAAK,CAACF,OAAO,cAAAqC,cAAA,uBAAbA,cAAA,CAAeC,KAAK,CAAC,CAAC;YACtBpC,KAAK,CAACF,OAAO,GAAG,IAAI;YACpBe,gBAAgB,CAAC,KAAK,CAAC;YACvB,IAAIX,cAAc,CAACJ,OAAO,EAAEI,cAAc,CAACJ,OAAO,CAACuC,SAAS,GAAG,IAAI;UACrE,CAAC,MAAM,IAAIR,GAAG,CAACK,KAAK,KAAK,CAAC,IAAIrC,SAAS,CAACC,OAAO,KAAK,WAAW,EAAE;YAC/DuB,OAAO,CAACC,GAAG,CAAC,sCAAsC,CAAC;YACnD1B,SAAS,CAAC,YAAY,CAAC;YACvB,MAAM0C,YAAY,CAAC7C,WAAW,CAAC;UACjC;UACA;QAEF,KAAK,OAAO;UACV4B,OAAO,CAACC,GAAG,CAAC,gBAAgB,EAAEO,GAAG,CAACU,KAAK,CAAC;UACxC,MAAMvC,KAAK,CAACF,OAAO,CAAC0C,oBAAoB,CAACX,GAAG,CAACU,KAAK,CAAC;UACnD;UACAvC,KAAK,CAACF,OAAO,CAAC2C,eAAe,CAAC,CAAC,CAACC,OAAO,CAAEC,CAAC,IAAK;YAAA,IAAAC,iBAAA;YAC7C,IAAI,EAAAA,iBAAA,GAAAD,CAAC,CAACE,QAAQ,CAACC,KAAK,cAAAF,iBAAA,uBAAhBA,iBAAA,CAAkBG,IAAI,MAAK,OAAO,EAAE;cACtCJ,CAAC,CAACK,SAAS,GAAG,UAAU;YAC1B;UACF,CAAC,CAAC;UACF;YACE,MAAMC,MAAM,GAAG,MAAMjD,KAAK,CAACF,OAAO,CAACoD,YAAY,CAAC,CAAC;YACjD,MAAMlD,KAAK,CAACF,OAAO,CAACqD,mBAAmB,CAACF,MAAM,CAAC;YAC/ClD,KAAK,CAACD,OAAO,CAACsD,IAAI,CAACtB,IAAI,CAACuB,SAAS,CAAC;cAAEpB,IAAI,EAAE,QAAQ;cAAEgB;YAAO,CAAC,CAAC,CAAC;UAChE;UACA;QACF,KAAK,QAAQ;UACX5B,OAAO,CAACC,GAAG,CAAC,iBAAiB,EAAEO,GAAG,CAACoB,MAAM,CAAC;UAC1C,MAAMjD,KAAK,CAACF,OAAO,CAAC0C,oBAAoB,CAACX,GAAG,CAACoB,MAAM,CAAC;UACpD;QACF,KAAK,WAAW;UACd5B,OAAO,CAACC,GAAG,CAAC,oBAAoB,EAAEO,GAAG,CAACyB,SAAS,CAAC;UAChD,MAAMtD,KAAK,CAACF,OAAO,CAACyD,eAAe,CAAC1B,GAAG,CAACyB,SAAS,CAAC;UAClD;QACF,KAAK,WAAW;UACdjC,OAAO,CAACC,GAAG,CAAC,WAAW,CAAC;UACxB1B,SAAS,CAAC,WAAW,CAAC;UACtB;QACF,KAAK,YAAY;UACfyB,OAAO,CAACC,GAAG,CAAC,YAAY,CAAC;UACzB1B,SAAS,CAAC,OAAO,CAAC;UAClB;QACF;UACE;MACJ;IACF,CAAC;;IAED;IACA,OAAO,MAAM;MAAA,IAAA4D,cAAA,EAAAC,eAAA;MACX,CAAAD,cAAA,GAAAzD,KAAK,CAACD,OAAO,cAAA0D,cAAA,uBAAbA,cAAA,CAAepB,KAAK,CAAC,CAAC;MACtB,CAAAqB,eAAA,GAAAzD,KAAK,CAACF,OAAO,cAAA2D,eAAA,uBAAbA,eAAA,CAAerB,KAAK,CAAC,CAAC;IACxB,CAAC;EACH,CAAC,EAAE,CAAC9C,MAAM,EAAEE,KAAK,EAAEC,WAAW,CAAC,CAAC;;EAEhC;EACA,eAAe6C,YAAYA,CAAC7C,WAAW,EAAE;IACvC4B,OAAO,CAACC,GAAG,CAAC,oBAAoB,EAAE,eAAe,EAAE;MAAE7B;IAAY,CAAC,CAAC;IACnEG,SAAS,CAAC,YAAY,CAAC;IAEvBI,KAAK,CAACF,OAAO,GAAG,IAAI4D,iBAAiB,CAAC;MACpCC,UAAU,EAAE,CAAC;QAAEC,IAAI,EAAE7C,OAAO,CAACC,GAAG,CAAC6C;MAAsB,CAAC;IAC1D,CAAC,CAAC;IACF7D,KAAK,CAACF,OAAO,CAACgE,uBAAuB,GAAG,MACtCzC,OAAO,CAACC,GAAG,CAAC,qBAAqB,EAAEtB,KAAK,CAACF,OAAO,CAACiE,eAAe,CAAC;IACnE/D,KAAK,CAACF,OAAO,CAACkE,0BAA0B,GAAG,MACzC3C,OAAO,CAACC,GAAG,CAAC,wBAAwB,EAAEtB,KAAK,CAACF,OAAO,CAACmE,kBAAkB,CAAC;;IAEzE;IACA9D,cAAc,CAACL,OAAO,GAAG,MAAMoE,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;MACjEC,KAAK,EAAE;IACT,CAAC,CAAC;IACFhD,OAAO,CAACC,GAAG,CAAC,kBAAkB,EAAEnB,cAAc,CAACL,OAAO,CAAC;;IAEvD;IACA,MAAMwE,SAAS,GAAG,KAAKC,MAAM,CAACC,YAAY,IAAID,MAAM,CAACE,kBAAkB,EAAE,CAAC;IAC1E,MAAMC,SAAS,GAAGJ,SAAS,CAACK,cAAc,CAAC,CAAC;IAC5C,MAAMC,IAAI,GAAGN,SAAS,CAACO,uBAAuB,CAAC1E,cAAc,CAACL,OAAO,CAAC;IACtE8E,IAAI,CAACE,OAAO,CAACJ,SAAS,CAAC;IACvBA,SAAS,CAACK,OAAO,GAAG,GAAG;IACvB,MAAMC,KAAK,GAAG,IAAIC,UAAU,CAACP,SAAS,CAACQ,iBAAiB,CAAC;IACzD,CAAC,SAASC,WAAWA,CAAA,EAAG;MACtBT,SAAS,CAACU,oBAAoB,CAACJ,KAAK,CAAC;MACrCzE,gBAAgB,CACdyE,KAAK,CAACK,MAAM,CAAC,CAACC,GAAG,EAAEC,CAAC,KAAKD,GAAG,GAAGC,CAAC,EAAE,CAAC,CAAC,GAAGP,KAAK,CAACQ,MAAM,GAAG,EACxD,CAAC;MACDC,qBAAqB,CAACN,WAAW,CAAC;IACpC,CAAC,EAAE,CAAC;;IAEJ;IACAhF,cAAc,CAACL,OAAO,CAAC4F,SAAS,CAAC,CAAC,CAAChD,OAAO,CAAEC,CAAC,IAAK;MAChDtB,OAAO,CAACC,GAAG,CAAC,WAAW,EAAEqB,CAAC,CAACI,IAAI,CAAC;MAChC/C,KAAK,CAACF,OAAO,CAAC6F,QAAQ,CAAChD,CAAC,EAAExC,cAAc,CAACL,OAAO,CAAC;IACnD,CAAC,CAAC;;IAEF;IACAE,KAAK,CAACF,OAAO,CAAC8F,OAAO,GAAG,CAAC;MAAEC,OAAO,EAAE,CAACC,MAAM;IAAE,CAAC,KAAK;MACjDzE,OAAO,CAACC,GAAG,CAAC,gBAAgB,EAAE,aAAa,EAAEwE,MAAM,CAAC;MACpD,IAAI5F,cAAc,CAACJ,OAAO,EAAE;QAC1BI,cAAc,CAACJ,OAAO,CAACuC,SAAS,GAAGyD,MAAM;MAC3C;MAEA,MAAMC,EAAE,GAAGD,MAAM,CAACE,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;MACrC,IAAID,EAAE,EAAE;QACNA,EAAE,CAACE,MAAM,GAAG,MAAMtF,cAAc,CAAC,IAAI,CAAC;QACtCoF,EAAE,CAACG,QAAQ,GAAG,MAAMvF,cAAc,CAAC,KAAK,CAAC;MAC3C;MAEA,IAAI,CAACH,cAAc,EAAE;QACnB,MAAM2F,SAAS,GAAG,KAAK5B,MAAM,CAACC,YAAY,IACxCD,MAAM,CAACE,kBAAkB,EAAE,CAAC;QAC9B,MAAM2B,SAAS,GAAGD,SAAS,CAACxB,cAAc,CAAC,CAAC;QAC5C,MAAM0B,IAAI,GAAGF,SAAS,CAACtB,uBAAuB,CAACiB,MAAM,CAAC;QACtDO,IAAI,CAACvB,OAAO,CAACsB,SAAS,CAAC;QACvBA,SAAS,CAACrB,OAAO,GAAG,GAAG;QACvB,MAAMuB,KAAK,GAAG,IAAIrB,UAAU,CAACmB,SAAS,CAAClB,iBAAiB,CAAC;QACzD,CAAC,SAASqB,YAAYA,CAAA,EAAG;UACvBH,SAAS,CAAChB,oBAAoB,CAACkB,KAAK,CAAC;UACrC7F,iBAAiB,CACf6F,KAAK,CAACjB,MAAM,CAAC,CAACC,GAAG,EAAEC,CAAC,KAAKD,GAAG,GAAGC,CAAC,EAAE,CAAC,CAAC,GAAGe,KAAK,CAACd,MAAM,GAAG,EACxD,CAAC;UACDC,qBAAqB,CAACc,YAAY,CAAC;QACrC,CAAC,EAAE,CAAC;MACN;IACF,CAAC;;IAED;IACA,IAAI9G,WAAW,EAAE;MACf4B,OAAO,CAACC,GAAG,CAAC,mCAAmC,CAAC;MAChDrB,cAAc,CAACH,OAAO,GAAGE,KAAK,CAACF,OAAO,CAAC0G,iBAAiB,CAAC,MAAM,CAAC;MAChEC,gBAAgB,CAAC,CAAC;IACpB,CAAC,MAAM;MACLzG,KAAK,CAACF,OAAO,CAAC4G,aAAa,GAAG,CAAC;QAAEC;MAAQ,CAAC,KAAK;QAC7CtF,OAAO,CAACC,GAAG,CAAC,kCAAkC,EAAEqF,OAAO,CAAC;QACxD1G,cAAc,CAACH,OAAO,GAAG6G,OAAO;QAChCF,gBAAgB,CAAC,CAAC;MACpB,CAAC;IACH;;IAEA;IACAzG,KAAK,CAACF,OAAO,CAAC8G,cAAc,GAAG,CAAC;MAAEtD;IAAU,CAAC,KAAK;MAChDjC,OAAO,CAACC,GAAG,CAAC,uBAAuB,EAAEgC,SAAS,CAAC;MAC/C,IAAIA,SAAS,EAAE;QACbvD,KAAK,CAACD,OAAO,CAACsD,IAAI,CAACtB,IAAI,CAACuB,SAAS,CAAC;UAAEpB,IAAI,EAAE,WAAW;UAAEqB;QAAU,CAAC,CAAC,CAAC;MACtE;IACF,CAAC;;IAED;IACA,IAAI7D,WAAW,EAAE;MACf,MAAM8C,KAAK,GAAG,MAAMvC,KAAK,CAACF,OAAO,CAAC+G,WAAW,CAAC,CAAC;MAC/CxF,OAAO,CAACC,GAAG,CAAC,eAAe,EAAEiB,KAAK,CAAC;MACnC,MAAMvC,KAAK,CAACF,OAAO,CAACqD,mBAAmB,CAACZ,KAAK,CAAC;MAC9CxC,KAAK,CAACD,OAAO,CAACsD,IAAI,CAACtB,IAAI,CAACuB,SAAS,CAAC;QAAEpB,IAAI,EAAE,OAAO;QAAEM;MAAM,CAAC,CAAC,CAAC;IAC9D;IAEA3C,SAAS,CAAC,WAAW,CAAC;IACtByB,OAAO,CAACC,GAAG,CAAC,oBAAoB,CAAC;EACnC;EAEA,SAASmF,gBAAgBA,CAAA,EAAG;IAC1BxG,cAAc,CAACH,OAAO,CAACsB,MAAM,GAAG,MAAM;MACpCC,OAAO,CAACC,GAAG,CAAC,oBAAoB,EAAE,cAAc,EAAErB,cAAc,CAACH,OAAO,CAAC;MACzEe,gBAAgB,CAAC,IAAI,CAAC;IACxB,CAAC;IACDZ,cAAc,CAACH,OAAO,CAAC0B,OAAO,GAAG,MAAM;MACrCH,OAAO,CAACC,GAAG,CAAC,sBAAsB,EAAE,YAAY,EAAErB,cAAc,CAACH,OAAO,CAAC;MACzEe,gBAAgB,CAAC,KAAK,CAAC;IACzB,CAAC;IACDZ,cAAc,CAACH,OAAO,CAAC2B,SAAS,GAAG,CAAC;MAAEC;IAAK,CAAC,KAAK;MAC/CL,OAAO,CAACC,GAAG,CAAC,uBAAuB,EAAE,eAAe,EAAEI,IAAI,CAAC;MAC3DrB,eAAe,CAAEyG,IAAI,IAAK,CAAC,GAAGA,IAAI,EAAE;QAAEC,MAAM,EAAE,MAAM;QAAEpF,IAAI,EAAED;MAAK,CAAC,CAAC,CAAC;IACtE,CAAC;EACH;;EAEA;EACA,SAASsF,WAAWA,CAACrF,IAAI,EAAE;IAAA,IAAAsF,qBAAA,EAAAC,sBAAA;IACzB7F,OAAO,CAACC,GAAG,CACT,iBAAiB,EACjBK,IAAI,EACJ,UAAU,GAAAsF,qBAAA,GACVhH,cAAc,CAACH,OAAO,cAAAmH,qBAAA,uBAAtBA,qBAAA,CAAwBE,UAC1B,CAAC;IACD9G,eAAe,CAAEyG,IAAI,IAAK,CAAC,GAAGA,IAAI,EAAE;MAAEC,MAAM,EAAE,OAAO;MAAEpF;IAAK,CAAC,CAAC,CAAC;IAE/D,IAAI,EAAAuF,sBAAA,GAAAjH,cAAc,CAACH,OAAO,cAAAoH,sBAAA,uBAAtBA,sBAAA,CAAwBC,UAAU,MAAK,MAAM,EAAE;MACjDlH,cAAc,CAACH,OAAO,CAACsD,IAAI,CAACzB,IAAI,CAAC;IACnC,CAAC,MAAM;MACLN,OAAO,CAACW,IAAI,CAAC,oDAAoD,EAAEL,IAAI,CAAC;IAC1E;EACF;EAEA,SAASyF,UAAUA,CAAA,EAAG;IAAA,IAAAC,qBAAA;IACpB,MAAM1E,CAAC,IAAA0E,qBAAA,GAAGlH,cAAc,CAACL,OAAO,cAAAuH,qBAAA,uBAAtBA,qBAAA,CAAwBrB,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;IACrD,IAAIrD,CAAC,EAAEA,CAAC,CAAC2E,OAAO,GAAG,CAAC3E,CAAC;EACvB;EAEA,SAAS4E,MAAMA,CAAA,EAAG;IAAA,IAAAC,sBAAA;IAChB,IAAI/H,WAAW,EAAE;MACfM,KAAK,CAACD,OAAO,CAACsD,IAAI,CAACtB,IAAI,CAACuB,SAAS,CAAC;QAAEpB,IAAI,EAAE;MAAW,CAAC,CAAC,CAAC;IAC1D;IACAZ,OAAO,CAACC,GAAG,CAAC,UAAU,CAAC;IACvB1B,SAAS,CAAC,OAAO,CAAC;IAClB,CAAA4H,sBAAA,GAAArH,cAAc,CAACL,OAAO,cAAA0H,sBAAA,uBAAtBA,sBAAA,CAAwB9B,SAAS,CAAC,CAAC,CAAChD,OAAO,CAAEC,CAAC,IAAKA,CAAC,CAAC8E,IAAI,CAAC,CAAC,CAAC;IAC5D,IAAIvH,cAAc,CAACJ,OAAO,EAAEI,cAAc,CAACJ,OAAO,CAACuC,SAAS,GAAG,IAAI;IACnEqF,UAAU,CAAC,MAAM;MAAA,IAAAC,eAAA,EAAAC,eAAA;MACf,CAAAD,eAAA,GAAA5H,KAAK,CAACD,OAAO,cAAA6H,eAAA,uBAAbA,eAAA,CAAevF,KAAK,CAAC,CAAC;MACtB,CAAAwF,eAAA,GAAA5H,KAAK,CAACF,OAAO,cAAA8H,eAAA,uBAAbA,eAAA,CAAexF,KAAK,CAAC,CAAC;IACxB,CAAC,EAAE,GAAG,CAAC;EACT;EAEA,OAAO;IACLlC,cAAc;IACdP,MAAM;IACNS,YAAY;IACZ4G,WAAW;IACXI,UAAU;IACVG,MAAM;IACNjH,aAAa;IACbE,cAAc;IACdE,WAAW;IACXE;EACF,CAAC;AACH;AAAClB,EAAA,CAtRuBL,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
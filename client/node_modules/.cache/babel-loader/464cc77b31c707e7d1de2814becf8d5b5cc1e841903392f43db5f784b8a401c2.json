{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef, useState } from \"react\";\nexport default function useWebRTC(callId, {\n  start = true,\n  isInitiator = false\n}) {\n  _s();\n  const wsRef = useRef();\n  const pcRef = useRef();\n  const dataChannelRef = useRef();\n  const remoteAudioRef = useRef();\n  const localStreamRef = useRef();\n  const [status, setStatus] = useState(\"waiting\");\n  const statusRef = useRef(status);\n  useEffect(() => {\n    statusRef.current = status;\n  }, [status]);\n  const [chatMessages, setChatMessages] = useState([]);\n  const [localSpeaking, setLocalSpeaking] = useState(false);\n  const [remoteSpeaking, setRemoteSpeaking] = useState(false);\n  const [remoteMuted, setRemoteMuted] = useState(false);\n  const latestPeers = useRef(1); // <-- pour garder la valeur la plus récente\n\n  // --- START = true déclenche appel SI peers >= 2 déjà reçu ---\n  useEffect(() => {\n    if (!start) return;\n    if (latestPeers.current >= 2 && statusRef.current === \"waiting\" && isInitiator) {\n      initiateCall(true);\n    }\n  }, [start, isInitiator]);\n\n  // --- Micro local ---\n  useEffect(() => {\n    if (!start) return;\n    navigator.mediaDevices.getUserMedia({\n      audio: true\n    }).then(stream => {\n      localStreamRef.current = stream;\n      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n      const analyser = audioCtx.createAnalyser();\n      const src = audioCtx.createMediaStreamSource(stream);\n      src.connect(analyser);\n      analyser.fftSize = 256;\n      const dataArr = new Uint8Array(analyser.frequencyBinCount);\n      (function detect() {\n        analyser.getByteFrequencyData(dataArr);\n        setLocalSpeaking(dataArr.reduce((a, v) => a + v, 0) / dataArr.length > 30);\n        requestAnimationFrame(detect);\n      })();\n    }).catch(err => console.error(\"Microphone error\", err));\n  }, [start]);\n\n  // --- WebSocket setup ---\n  useEffect(() => {\n    const serverUrl = process.env.REACT_APP_SERVER_URL;\n    wsRef.current = new WebSocket(`${serverUrl.replace(/^http/, \"ws\")}?roomId=${callId}`);\n    wsRef.current.onopen = () => console.log(\"WS open\");\n    wsRef.current.onclose = () => console.log(\"WS closed\");\n    wsRef.current.onmessage = async ({\n      data\n    }) => {\n      let msg;\n      try {\n        msg = JSON.parse(data);\n      } catch {\n        return;\n      }\n      switch (msg.type) {\n        case \"room-status\":\n          latestPeers.current = msg.peers;\n          console.log(\"Room peers:\", msg.peers);\n          if (msg.peers >= 2 && statusRef.current === \"waiting\" && start && isInitiator) {\n            await initiateCall(true);\n          }\n          break;\n        case \"offer\":\n          if (!pcRef.current && start) await initiateCall(false);\n          await pcRef.current.setRemoteDescription(msg.offer);\n          const answer = await pcRef.current.createAnswer();\n          await pcRef.current.setLocalDescription(answer);\n          wsRef.current.send(JSON.stringify({\n            type: \"answer\",\n            answer\n          }));\n          break;\n        case \"answer\":\n          await pcRef.current.setRemoteDescription(msg.answer);\n          break;\n        case \"candidate\":\n          await pcRef.current.addIceCandidate(msg.candidate);\n          break;\n        case \"peer-left\":\n          setStatus(\"peer-left\");\n          break;\n        case \"call-ended\":\n          setStatus(\"ended\");\n          break;\n      }\n    };\n    return () => {\n      var _wsRef$current, _pcRef$current;\n      (_wsRef$current = wsRef.current) === null || _wsRef$current === void 0 ? void 0 : _wsRef$current.close();\n      (_pcRef$current = pcRef.current) === null || _pcRef$current === void 0 ? void 0 : _pcRef$current.close();\n    };\n  }, [callId, start, isInitiator]);\n\n  // --- Initialisation WebRTC ---\n  async function initiateCall(isOfferer) {\n    if (statusRef.current === \"connected\" || statusRef.current === \"connecting\") return;\n    setStatus(\"connecting\");\n    pcRef.current = new RTCPeerConnection({\n      iceServers: [{\n        urls: process.env.REACT_APP_STUN_SERVER\n      }]\n    });\n    if (!localStreamRef.current) {\n      localStreamRef.current = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n    }\n    localStreamRef.current.getTracks().forEach(track => pcRef.current.addTrack(track, localStreamRef.current));\n    pcRef.current.ontrack = ({\n      streams: [stream]\n    }) => {\n      if (remoteAudioRef.current) {\n        remoteAudioRef.current.srcObject = stream;\n        remoteAudioRef.current.play().catch(e => console.warn(\"Playback error\", e));\n      }\n      const rt = stream.getAudioTracks()[0];\n      if (rt) {\n        rt.onmute = () => setRemoteMuted(true);\n        rt.onunmute = () => setRemoteMuted(false);\n      }\n      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n      const analyser = audioCtx.createAnalyser();\n      const src = audioCtx.createMediaStreamSource(stream);\n      src.connect(analyser);\n      analyser.fftSize = 256;\n      const dataArr = new Uint8Array(analyser.frequencyBinCount);\n      (function detect() {\n        analyser.getByteFrequencyData(dataArr);\n        setRemoteSpeaking(dataArr.reduce((a, v) => a + v, 0) / dataArr.length > 30);\n        requestAnimationFrame(detect);\n      })();\n    };\n    if (isOfferer) {\n      dataChannelRef.current = pcRef.current.createDataChannel(\"chat\");\n      setupDataChannel();\n    } else {\n      pcRef.current.ondatachannel = ({\n        channel\n      }) => {\n        dataChannelRef.current = channel;\n        setupDataChannel();\n      };\n    }\n    pcRef.current.onicecandidate = ({\n      candidate\n    }) => {\n      if (candidate) {\n        wsRef.current.send(JSON.stringify({\n          type: \"candidate\",\n          candidate\n        }));\n      }\n    };\n    if (isOfferer) {\n      const offer = await pcRef.current.createOffer();\n      await pcRef.current.setLocalDescription(offer);\n      wsRef.current.send(JSON.stringify({\n        type: \"offer\",\n        offer\n      }));\n    }\n    setStatus(\"connected\");\n  }\n  function setupDataChannel() {\n    dataChannelRef.current.onopen = () => console.log(\"DataChannel open\");\n    dataChannelRef.current.onmessage = ({\n      data\n    }) => {\n      var _parsed;\n      let parsed;\n      try {\n        parsed = JSON.parse(data);\n      } catch {}\n      if (((_parsed = parsed) === null || _parsed === void 0 ? void 0 : _parsed.type) === \"mute\") {\n        setRemoteMuted(parsed.muted);\n      } else {\n        setChatMessages(prev => [...prev, {\n          sender: \"peer\",\n          text: data\n        }]);\n      }\n    };\n  }\n  function sendMessage(text) {\n    var _dataChannelRef$curre;\n    if (((_dataChannelRef$curre = dataChannelRef.current) === null || _dataChannelRef$curre === void 0 ? void 0 : _dataChannelRef$curre.readyState) === \"open\") {\n      dataChannelRef.current.send(text);\n      setChatMessages(prev => [...prev, {\n        sender: \"local\",\n        text\n      }]);\n    }\n  }\n  function toggleMute() {\n    var _localStreamRef$curre, _dataChannelRef$curre2;\n    const track = (_localStreamRef$curre = localStreamRef.current) === null || _localStreamRef$curre === void 0 ? void 0 : _localStreamRef$curre.getAudioTracks()[0];\n    if (!track) return;\n    track.enabled = !track.enabled;\n    if (!isInitiator && ((_dataChannelRef$curre2 = dataChannelRef.current) === null || _dataChannelRef$curre2 === void 0 ? void 0 : _dataChannelRef$curre2.readyState) === \"open\") {\n      dataChannelRef.current.send(JSON.stringify({\n        type: \"mute\",\n        muted: !track.enabled\n      }));\n    }\n  }\n  function hangUp() {\n    var _localStreamRef$curre2;\n    if (isInitiator) {\n      wsRef.current.send(JSON.stringify({\n        type: \"end-call\"\n      }));\n    }\n    setStatus(\"ended\");\n    (_localStreamRef$curre2 = localStreamRef.current) === null || _localStreamRef$curre2 === void 0 ? void 0 : _localStreamRef$curre2.getTracks().forEach(t => t.stop());\n    if (remoteAudioRef.current) remoteAudioRef.current.srcObject = null;\n    setTimeout(() => {\n      var _wsRef$current2, _pcRef$current2;\n      (_wsRef$current2 = wsRef.current) === null || _wsRef$current2 === void 0 ? void 0 : _wsRef$current2.close();\n      (_pcRef$current2 = pcRef.current) === null || _pcRef$current2 === void 0 ? void 0 : _pcRef$current2.close();\n    }, 100);\n  }\n  return {\n    remoteAudioRef,\n    status,\n    chatMessages,\n    sendMessage,\n    toggleMute,\n    hangUp,\n    localSpeaking,\n    remoteSpeaking,\n    remoteMuted\n  };\n}\n_s(useWebRTC, \"UB6s+OpgkFjjbxTK8ODd0lcl5Pw=\");","map":{"version":3,"names":["useEffect","useRef","useState","useWebRTC","callId","start","isInitiator","_s","wsRef","pcRef","dataChannelRef","remoteAudioRef","localStreamRef","status","setStatus","statusRef","current","chatMessages","setChatMessages","localSpeaking","setLocalSpeaking","remoteSpeaking","setRemoteSpeaking","remoteMuted","setRemoteMuted","latestPeers","initiateCall","navigator","mediaDevices","getUserMedia","audio","then","stream","audioCtx","window","AudioContext","webkitAudioContext","analyser","createAnalyser","src","createMediaStreamSource","connect","fftSize","dataArr","Uint8Array","frequencyBinCount","detect","getByteFrequencyData","reduce","a","v","length","requestAnimationFrame","catch","err","console","error","serverUrl","process","env","REACT_APP_SERVER_URL","WebSocket","replace","onopen","log","onclose","onmessage","data","msg","JSON","parse","type","peers","setRemoteDescription","offer","answer","createAnswer","setLocalDescription","send","stringify","addIceCandidate","candidate","_wsRef$current","_pcRef$current","close","isOfferer","RTCPeerConnection","iceServers","urls","REACT_APP_STUN_SERVER","getTracks","forEach","track","addTrack","ontrack","streams","srcObject","play","e","warn","rt","getAudioTracks","onmute","onunmute","createDataChannel","setupDataChannel","ondatachannel","channel","onicecandidate","createOffer","_parsed","parsed","muted","prev","sender","text","sendMessage","_dataChannelRef$curre","readyState","toggleMute","_localStreamRef$curre","_dataChannelRef$curre2","enabled","hangUp","_localStreamRef$curre2","t","stop","setTimeout","_wsRef$current2","_pcRef$current2"],"sources":["/Users/theodiamant/Desktop/webrtc/client/src/hooks/useWebRTC.js"],"sourcesContent":["import { useEffect, useRef, useState } from \"react\";\n\nexport default function useWebRTC(callId, { start = true, isInitiator = false }) {\n  const wsRef = useRef();\n  const pcRef = useRef();\n  const dataChannelRef = useRef();\n  const remoteAudioRef = useRef();\n  const localStreamRef = useRef();\n  const [status, setStatus] = useState(\"waiting\");\n  const statusRef = useRef(status);\n  useEffect(() => { statusRef.current = status; }, [status]);\n\n  const [chatMessages, setChatMessages] = useState([]);\n  const [localSpeaking, setLocalSpeaking] = useState(false);\n  const [remoteSpeaking, setRemoteSpeaking] = useState(false);\n  const [remoteMuted, setRemoteMuted] = useState(false);\n\n  const latestPeers = useRef(1); // <-- pour garder la valeur la plus récente\n\n  // --- START = true déclenche appel SI peers >= 2 déjà reçu ---\n  useEffect(() => {\n    if (!start) return;\n    if (latestPeers.current >= 2 && statusRef.current === \"waiting\" && isInitiator) {\n      initiateCall(true);\n    }\n  }, [start, isInitiator]);\n\n  // --- Micro local ---\n  useEffect(() => {\n    if (!start) return;\n    navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {\n      localStreamRef.current = stream;\n      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n      const analyser = audioCtx.createAnalyser();\n      const src = audioCtx.createMediaStreamSource(stream);\n      src.connect(analyser);\n      analyser.fftSize = 256;\n      const dataArr = new Uint8Array(analyser.frequencyBinCount);\n      (function detect() {\n        analyser.getByteFrequencyData(dataArr);\n        setLocalSpeaking(dataArr.reduce((a, v) => a + v, 0) / dataArr.length > 30);\n        requestAnimationFrame(detect);\n      })();\n    }).catch(err => console.error(\"Microphone error\", err));\n  }, [start]);\n\n  // --- WebSocket setup ---\n  useEffect(() => {\n    const serverUrl = process.env.REACT_APP_SERVER_URL;\n    wsRef.current = new WebSocket(`${serverUrl.replace(/^http/, \"ws\")}?roomId=${callId}`);\n    wsRef.current.onopen = () => console.log(\"WS open\");\n    wsRef.current.onclose = () => console.log(\"WS closed\");\n\n    wsRef.current.onmessage = async ({ data }) => {\n      let msg;\n      try { msg = JSON.parse(data); } catch { return; }\n\n      switch (msg.type) {\n        case \"room-status\":\n          latestPeers.current = msg.peers;\n          console.log(\"Room peers:\", msg.peers);\n          if (msg.peers >= 2 && statusRef.current === \"waiting\" && start && isInitiator) {\n            await initiateCall(true);\n          }\n          break;\n        case \"offer\":\n          if (!pcRef.current && start) await initiateCall(false);\n          await pcRef.current.setRemoteDescription(msg.offer);\n          const answer = await pcRef.current.createAnswer();\n          await pcRef.current.setLocalDescription(answer);\n          wsRef.current.send(JSON.stringify({ type: \"answer\", answer }));\n          break;\n        case \"answer\":\n          await pcRef.current.setRemoteDescription(msg.answer);\n          break;\n        case \"candidate\":\n          await pcRef.current.addIceCandidate(msg.candidate);\n          break;\n        case \"peer-left\":\n          setStatus(\"peer-left\");\n          break;\n        case \"call-ended\":\n          setStatus(\"ended\");\n          break;\n      }\n    };\n\n    return () => {\n      wsRef.current?.close();\n      pcRef.current?.close();\n    };\n  }, [callId, start, isInitiator]);\n\n  // --- Initialisation WebRTC ---\n  async function initiateCall(isOfferer) {\n    if (statusRef.current === \"connected\" || statusRef.current === \"connecting\") return;\n    setStatus(\"connecting\");\n\n    pcRef.current = new RTCPeerConnection({\n      iceServers: [{ urls: process.env.REACT_APP_STUN_SERVER }],\n    });\n\n    if (!localStreamRef.current) {\n      localStreamRef.current = await navigator.mediaDevices.getUserMedia({ audio: true });\n    }\n\n    localStreamRef.current.getTracks().forEach(track =>\n      pcRef.current.addTrack(track, localStreamRef.current)\n    );\n\n    pcRef.current.ontrack = ({ streams: [stream] }) => {\n      if (remoteAudioRef.current) {\n        remoteAudioRef.current.srcObject = stream;\n        remoteAudioRef.current.play().catch(e => console.warn(\"Playback error\", e));\n      }\n\n      const rt = stream.getAudioTracks()[0];\n      if (rt) {\n        rt.onmute = () => setRemoteMuted(true);\n        rt.onunmute = () => setRemoteMuted(false);\n      }\n\n      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n      const analyser = audioCtx.createAnalyser();\n      const src = audioCtx.createMediaStreamSource(stream);\n      src.connect(analyser);\n      analyser.fftSize = 256;\n      const dataArr = new Uint8Array(analyser.frequencyBinCount);\n      (function detect() {\n        analyser.getByteFrequencyData(dataArr);\n        setRemoteSpeaking(dataArr.reduce((a, v) => a + v, 0) / dataArr.length > 30);\n        requestAnimationFrame(detect);\n      })();\n    };\n\n    if (isOfferer) {\n      dataChannelRef.current = pcRef.current.createDataChannel(\"chat\");\n      setupDataChannel();\n    } else {\n      pcRef.current.ondatachannel = ({ channel }) => {\n        dataChannelRef.current = channel;\n        setupDataChannel();\n      };\n    }\n\n    pcRef.current.onicecandidate = ({ candidate }) => {\n      if (candidate) {\n        wsRef.current.send(JSON.stringify({ type: \"candidate\", candidate }));\n      }\n    };\n\n    if (isOfferer) {\n      const offer = await pcRef.current.createOffer();\n      await pcRef.current.setLocalDescription(offer);\n      wsRef.current.send(JSON.stringify({ type: \"offer\", offer }));\n    }\n\n    setStatus(\"connected\");\n  }\n\n  function setupDataChannel() {\n    dataChannelRef.current.onopen = () => console.log(\"DataChannel open\");\n    dataChannelRef.current.onmessage = ({ data }) => {\n      let parsed;\n      try { parsed = JSON.parse(data); } catch {}\n      if (parsed?.type === \"mute\") {\n        setRemoteMuted(parsed.muted);\n      } else {\n        setChatMessages(prev => [...prev, { sender: \"peer\", text: data }]);\n      }\n    };\n  }\n\n  function sendMessage(text) {\n    if (dataChannelRef.current?.readyState === \"open\") {\n      dataChannelRef.current.send(text);\n      setChatMessages(prev => [...prev, { sender: \"local\", text }]);\n    }\n  }\n\n  function toggleMute() {\n    const track = localStreamRef.current?.getAudioTracks()[0];\n    if (!track) return;\n    track.enabled = !track.enabled;\n    if (!isInitiator && dataChannelRef.current?.readyState === \"open\") {\n      dataChannelRef.current.send(JSON.stringify({ type: \"mute\", muted: !track.enabled }));\n    }\n  }\n\n  function hangUp() {\n    if (isInitiator) {\n      wsRef.current.send(JSON.stringify({ type: \"end-call\" }));\n    }\n    setStatus(\"ended\");\n    localStreamRef.current?.getTracks().forEach(t => t.stop());\n    if (remoteAudioRef.current) remoteAudioRef.current.srcObject = null;\n    setTimeout(() => {\n      wsRef.current?.close();\n      pcRef.current?.close();\n    }, 100);\n  }\n\n  return {\n    remoteAudioRef,\n    status,\n    chatMessages,\n    sendMessage,\n    toggleMute,\n    hangUp,\n    localSpeaking,\n    remoteSpeaking,\n    remoteMuted,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"var _s = $RefreshSig$();\n// src/hooks/useWebRTC.js\nimport { useEffect, useRef, useState } from \"react\";\nexport default function useWebRTC(callId, {\n  start = false,\n  isInitiator = false,\n  localStream = null\n}) {\n  _s();\n  const [status, setStatus] = useState(\"waiting\");\n  const [chatMessages, setChatMessages] = useState([]);\n  const [isChannelOpen, setIsChannelOpen] = useState(false);\n  const [localSpeaking, setLocalSpeaking] = useState(false);\n  const [remoteSpeaking, setRemoteSpeaking] = useState(false);\n  const wsRef = useRef(null);\n  const pcRef = useRef(null);\n  const dcRef = useRef(null);\n  const remoteAudioRef = useRef(null);\n\n  // —————————————\n  // 1) Détection de la voix locale\n  useEffect(() => {\n    if (!localStream) return;\n    const audioCtx = new AudioContext();\n    const source = audioCtx.createMediaStreamSource(localStream);\n    const analyser = audioCtx.createAnalyser();\n    analyser.fftSize = 256;\n    source.connect(analyser);\n    const data = new Uint8Array(analyser.frequencyBinCount);\n    let rafId;\n    const detect = () => {\n      analyser.getByteTimeDomainData(data);\n      let sum = 0;\n      for (let i = 0; i < data.length; i++) {\n        const v = data[i] - 128;\n        sum += v * v;\n      }\n      const rms = Math.sqrt(sum / data.length);\n      setLocalSpeaking(rms > 10);\n      rafId = requestAnimationFrame(detect);\n    };\n    detect();\n    return () => {\n      cancelAnimationFrame(rafId);\n      audioCtx.close();\n    };\n  }, [localStream]);\n\n  // —————————————\n  // 2) Signaling WebSocket & RTC\n  useEffect(() => {\n    if (!start) return;\n    const ws = new WebSocket(process.env.REACT_APP_SERVER_URL.replace(/^http/, \"ws\") + `?roomId=${callId}`);\n    wsRef.current = ws;\n    ws.onopen = () => console.log(\"WS ▶︎ open\");\n    ws.onmessage = async ({\n      data\n    }) => {\n      const msg = JSON.parse(data);\n      switch (msg.type) {\n        case \"room-status\":\n          if (msg.peers === 2 && status === \"waiting\") await _startCall();\n          break;\n        case \"offer\":\n          await pcRef.current.setRemoteDescription(msg.offer);\n          await _createAndSendAnswer();\n          break;\n        case \"answer\":\n          await pcRef.current.setRemoteDescription(msg.answer);\n          break;\n        case \"candidate\":\n          if (msg.candidate) await pcRef.current.addIceCandidate(msg.candidate);\n          break;\n        case \"end-call\":\n          _hangUp();\n          break;\n      }\n    };\n    ws.onclose = () => console.log(\"WS ▶︎ closed\");\n    return () => {\n      var _pcRef$current;\n      ws.close();\n      (_pcRef$current = pcRef.current) === null || _pcRef$current === void 0 ? void 0 : _pcRef$current.close();\n    };\n  }, [callId, start, localStream, status]);\n  async function _startCall() {\n    if (!localStream) {\n      console.warn(\"pas de MediaStream prêt\");\n      return;\n    }\n    setStatus(\"connecting\");\n    const pc = new RTCPeerConnection({\n      iceServers: [{\n        urls: process.env.REACT_APP_STUN_SERVER\n      }]\n    });\n    pcRef.current = pc;\n\n    // suivi du state\n    pc.onconnectionstatechange = () => {\n      if (pc.connectionState === \"connected\") setStatus(\"connected\");else if (pc.connectionState === \"disconnected\" || pc.connectionState === \"failed\") setStatus(\"peer-left\");else if (pc.connectionState === \"connecting\") setStatus(\"connecting\");\n    };\n\n    // ICE\n    pc.onicecandidate = ({\n      candidate\n    }) => {\n      if (candidate) wsRef.current.send(JSON.stringify({\n        type: \"candidate\",\n        candidate\n      }));\n    };\n\n    // réception de l’audio distant + détection de voix\n    pc.ontrack = ({\n      streams: [stream]\n    }) => {\n      if (remoteAudioRef.current) {\n        remoteAudioRef.current.srcObject = stream;\n\n        // setup remote analyser\n        const audioCtx = new AudioContext();\n        const source = audioCtx.createMediaStreamSource(stream);\n        const analyser = audioCtx.createAnalyser();\n        analyser.fftSize = 256;\n        source.connect(analyser);\n        const data = new Uint8Array(analyser.frequencyBinCount);\n        let rafId;\n        const detect = () => {\n          analyser.getByteTimeDomainData(data);\n          let sum = 0;\n          for (let i = 0; i < data.length; i++) {\n            const v = data[i] - 128;\n            sum += v * v;\n          }\n          const rms = Math.sqrt(sum / data.length);\n          setRemoteSpeaking(rms > 10);\n          rafId = requestAnimationFrame(detect);\n        };\n        detect();\n\n        // nettoyer si on quitte\n        return () => {\n          cancelAnimationFrame(rafId);\n          audioCtx.close();\n        };\n      }\n    };\n\n    // envoi des pistes locales\n    localStream.getTracks().forEach(track => {\n      pc.addTrack(track, localStream);\n    });\n\n    // data channel pour le chat\n    if (isInitiator) {\n      const dc = pc.createDataChannel(\"chat\");\n      dcRef.current = dc;\n      _setupDataChannel(dc);\n    } else {\n      pc.ondatachannel = ({\n        channel\n      }) => {\n        dcRef.current = channel;\n        _setupDataChannel(channel);\n      };\n    }\n\n    // création de l’offre\n    if (isInitiator) {\n      const offer = await pc.createOffer();\n      await pc.setLocalDescription(offer);\n      wsRef.current.send(JSON.stringify({\n        type: \"offer\",\n        offer\n      }));\n    }\n  }\n  async function _createAndSendAnswer() {\n    const pc = pcRef.current;\n    const answer = await pc.createAnswer();\n    await pc.setLocalDescription(answer);\n    wsRef.current.send(JSON.stringify({\n      type: \"answer\",\n      answer\n    }));\n  }\n  function _setupDataChannel(dc) {\n    dc.onopen = () => setIsChannelOpen(true);\n    dc.onclose = () => setIsChannelOpen(false);\n    dc.onmessage = ({\n      data\n    }) => setChatMessages(m => [...m, {\n      sender: \"peer\",\n      text: data\n    }]);\n  }\n  function sendMessage(text) {\n    var _dcRef$current;\n    setChatMessages(m => [...m, {\n      sender: \"local\",\n      text\n    }]);\n    if (((_dcRef$current = dcRef.current) === null || _dcRef$current === void 0 ? void 0 : _dcRef$current.readyState) === \"open\") dcRef.current.send(text);\n  }\n  function toggleMute() {\n    const t = localStream === null || localStream === void 0 ? void 0 : localStream.getAudioTracks()[0];\n    if (t) t.enabled = !t;\n  }\n  function _hangUp() {\n    var _pcRef$current2;\n    setStatus(\"ended\");\n    localStream === null || localStream === void 0 ? void 0 : localStream.getTracks().forEach(t => t.stop());\n    (_pcRef$current2 = pcRef.current) === null || _pcRef$current2 === void 0 ? void 0 : _pcRef$current2.close();\n    wsRef.current.send(JSON.stringify({\n      type: \"end-call\"\n    }));\n    wsRef.current.close();\n  }\n  return {\n    remoteAudioRef,\n    status,\n    chatMessages,\n    sendMessage,\n    toggleMute,\n    hangUp: _hangUp,\n    isChannelOpen,\n    localSpeaking,\n    remoteSpeaking\n  };\n}\n_s(useWebRTC, \"KPvZztXmy8nIBhly3w2YrxrslRw=\");","map":{"version":3,"names":["useEffect","useRef","useState","useWebRTC","callId","start","isInitiator","localStream","_s","status","setStatus","chatMessages","setChatMessages","isChannelOpen","setIsChannelOpen","localSpeaking","setLocalSpeaking","remoteSpeaking","setRemoteSpeaking","wsRef","pcRef","dcRef","remoteAudioRef","audioCtx","AudioContext","source","createMediaStreamSource","analyser","createAnalyser","fftSize","connect","data","Uint8Array","frequencyBinCount","rafId","detect","getByteTimeDomainData","sum","i","length","v","rms","Math","sqrt","requestAnimationFrame","cancelAnimationFrame","close","ws","WebSocket","process","env","REACT_APP_SERVER_URL","replace","current","onopen","console","log","onmessage","msg","JSON","parse","type","peers","_startCall","setRemoteDescription","offer","_createAndSendAnswer","answer","candidate","addIceCandidate","_hangUp","onclose","_pcRef$current","warn","pc","RTCPeerConnection","iceServers","urls","REACT_APP_STUN_SERVER","onconnectionstatechange","connectionState","onicecandidate","send","stringify","ontrack","streams","stream","srcObject","getTracks","forEach","track","addTrack","dc","createDataChannel","_setupDataChannel","ondatachannel","channel","createOffer","setLocalDescription","createAnswer","m","sender","text","sendMessage","_dcRef$current","readyState","toggleMute","t","getAudioTracks","enabled","_pcRef$current2","stop","hangUp"],"sources":["/Users/theodiamant/Desktop/webrtc/client/src/hooks/useWebRTC.js"],"sourcesContent":["// src/hooks/useWebRTC.js\nimport { useEffect, useRef, useState } from \"react\";\n\nexport default function useWebRTC(\n  callId,\n  { start = false, isInitiator = false, localStream = null }\n) {\n  const [status, setStatus] = useState(\"waiting\");\n  const [chatMessages, setChatMessages] = useState([]);\n  const [isChannelOpen, setIsChannelOpen] = useState(false);\n  const [localSpeaking, setLocalSpeaking] = useState(false);\n  const [remoteSpeaking, setRemoteSpeaking] = useState(false);\n\n  const wsRef = useRef(null);\n  const pcRef = useRef(null);\n  const dcRef = useRef(null);\n  const remoteAudioRef = useRef(null);\n\n  // —————————————\n  // 1) Détection de la voix locale\n  useEffect(() => {\n    if (!localStream) return;\n    const audioCtx = new AudioContext();\n    const source = audioCtx.createMediaStreamSource(localStream);\n    const analyser = audioCtx.createAnalyser();\n    analyser.fftSize = 256;\n    source.connect(analyser);\n    const data = new Uint8Array(analyser.frequencyBinCount);\n    let rafId;\n\n    const detect = () => {\n      analyser.getByteTimeDomainData(data);\n      let sum = 0;\n      for (let i = 0; i < data.length; i++) {\n        const v = data[i] - 128;\n        sum += v * v;\n      }\n      const rms = Math.sqrt(sum / data.length);\n      setLocalSpeaking(rms > 10);\n      rafId = requestAnimationFrame(detect);\n    };\n    detect();\n\n    return () => {\n      cancelAnimationFrame(rafId);\n      audioCtx.close();\n    };\n  }, [localStream]);\n\n  // —————————————\n  // 2) Signaling WebSocket & RTC\n  useEffect(() => {\n    if (!start) return;\n    const ws = new WebSocket(\n      process.env.REACT_APP_SERVER_URL.replace(/^http/, \"ws\") +\n        `?roomId=${callId}`\n    );\n    wsRef.current = ws;\n\n    ws.onopen = () => console.log(\"WS ▶︎ open\");\n    ws.onmessage = async ({ data }) => {\n      const msg = JSON.parse(data);\n      switch (msg.type) {\n        case \"room-status\":\n          if (msg.peers === 2 && status === \"waiting\") await _startCall();\n          break;\n        case \"offer\":\n          await pcRef.current.setRemoteDescription(msg.offer);\n          await _createAndSendAnswer();\n          break;\n        case \"answer\":\n          await pcRef.current.setRemoteDescription(msg.answer);\n          break;\n        case \"candidate\":\n          if (msg.candidate) await pcRef.current.addIceCandidate(msg.candidate);\n          break;\n        case \"end-call\":\n          _hangUp();\n          break;\n      }\n    };\n    ws.onclose = () => console.log(\"WS ▶︎ closed\");\n\n    return () => {\n      ws.close();\n      pcRef.current?.close();\n    };\n  }, [callId, start, localStream, status]);\n\n  async function _startCall() {\n    if (!localStream) {\n      console.warn(\"pas de MediaStream prêt\");\n      return;\n    }\n    setStatus(\"connecting\");\n    const pc = new RTCPeerConnection({\n      iceServers: [{ urls: process.env.REACT_APP_STUN_SERVER }],\n    });\n    pcRef.current = pc;\n\n    // suivi du state\n    pc.onconnectionstatechange = () => {\n      if (pc.connectionState === \"connected\") setStatus(\"connected\");\n      else if (\n        pc.connectionState === \"disconnected\" ||\n        pc.connectionState === \"failed\"\n      )\n        setStatus(\"peer-left\");\n      else if (pc.connectionState === \"connecting\")\n        setStatus(\"connecting\");\n    };\n\n    // ICE\n    pc.onicecandidate = ({ candidate }) => {\n      if (candidate)\n        wsRef.current.send(JSON.stringify({ type: \"candidate\", candidate }));\n    };\n\n    // réception de l’audio distant + détection de voix\n    pc.ontrack = ({ streams: [stream] }) => {\n      if (remoteAudioRef.current) {\n        remoteAudioRef.current.srcObject = stream;\n\n        // setup remote analyser\n        const audioCtx = new AudioContext();\n        const source = audioCtx.createMediaStreamSource(stream);\n        const analyser = audioCtx.createAnalyser();\n        analyser.fftSize = 256;\n        source.connect(analyser);\n        const data = new Uint8Array(analyser.frequencyBinCount);\n        let rafId;\n        const detect = () => {\n          analyser.getByteTimeDomainData(data);\n          let sum = 0;\n          for (let i = 0; i < data.length; i++) {\n            const v = data[i] - 128;\n            sum += v * v;\n          }\n          const rms = Math.sqrt(sum / data.length);\n          setRemoteSpeaking(rms > 10);\n          rafId = requestAnimationFrame(detect);\n        };\n        detect();\n\n        // nettoyer si on quitte\n        return () => {\n          cancelAnimationFrame(rafId);\n          audioCtx.close();\n        };\n      }\n    };\n\n    // envoi des pistes locales\n    localStream.getTracks().forEach((track) => {\n      pc.addTrack(track, localStream);\n    });\n\n    // data channel pour le chat\n    if (isInitiator) {\n      const dc = pc.createDataChannel(\"chat\");\n      dcRef.current = dc;\n      _setupDataChannel(dc);\n    } else {\n      pc.ondatachannel = ({ channel }) => {\n        dcRef.current = channel;\n        _setupDataChannel(channel);\n      };\n    }\n\n    // création de l’offre\n    if (isInitiator) {\n      const offer = await pc.createOffer();\n      await pc.setLocalDescription(offer);\n      wsRef.current.send(JSON.stringify({ type: \"offer\", offer }));\n    }\n  }\n\n  async function _createAndSendAnswer() {\n    const pc = pcRef.current;\n    const answer = await pc.createAnswer();\n    await pc.setLocalDescription(answer);\n    wsRef.current.send(JSON.stringify({ type: \"answer\", answer }));\n  }\n\n  function _setupDataChannel(dc) {\n    dc.onopen = () => setIsChannelOpen(true);\n    dc.onclose = () => setIsChannelOpen(false);\n    dc.onmessage = ({ data }) =>\n      setChatMessages((m) => [...m, { sender: \"peer\", text: data }]);\n  }\n\n  function sendMessage(text) {\n    setChatMessages((m) => [...m, { sender: \"local\", text }]);\n    if (dcRef.current?.readyState === \"open\") dcRef.current.send(text);\n  }\n\n  function toggleMute() {\n    const t = localStream?.getAudioTracks()[0];\n    if (t) t.enabled = !t;\n  }\n\n  function _hangUp() {\n    setStatus(\"ended\");\n    localStream?.getTracks().forEach((t) => t.stop());\n    pcRef.current?.close();\n    wsRef.current.send(JSON.stringify({ type: \"end-call\" }));\n    wsRef.current.close();\n  }\n\n  return {\n    remoteAudioRef,\n    status,\n    chatMessages,\n    sendMessage,\n    toggleMute,\n    hangUp: _hangUp,\n    isChannelOpen,\n    localSpeaking,\n    remoteSpeaking,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
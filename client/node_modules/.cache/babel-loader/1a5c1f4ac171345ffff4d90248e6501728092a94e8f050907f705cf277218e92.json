{"ast":null,"code":"var _s = $RefreshSig$();\n// src/hooks/useWebRTC.js\nimport { useEffect, useRef, useState } from \"react\";\nexport default function useWebRTC(callId, {\n  start = true,\n  isInitiator = false\n}) {\n  _s();\n  const [status, setStatus] = useState(\"waiting\"); // waiting → connecting → connected → peer-left → ended\n  const wsRef = useRef(null);\n  const pcRef = useRef(null);\n  const dcRef = useRef(null);\n  const localStreamRef = useRef(null);\n  const remoteAudioRef = useRef(null);\n  const [chatMessages, setChatMessages] = useState([]);\n  const [isChannelOpen, setIsChannelOpen] = useState(false);\n\n  // 1) getUserMedia une seule fois\n  useEffect(() => {\n    navigator.mediaDevices.getUserMedia({\n      audio: true\n    }).then(stream => localStreamRef.current = stream).catch(err => console.error(\"Micro inaccessible :\", err));\n  }, []);\n\n  // 2) Signaling\n  useEffect(() => {\n    if (!start) return;\n    const ws = new WebSocket(process.env.REACT_APP_SERVER_URL.replace(/^http/, \"ws\") + `?roomId=${callId}`);\n    wsRef.current = ws;\n    ws.onopen = () => console.log(\"WS ▶︎ open\");\n    ws.onmessage = async ({\n      data\n    }) => {\n      const msg = JSON.parse(data);\n      switch (msg.type) {\n        case \"room-status\":\n          // Dès qu'on a 2 peers et qu'on est encore en \"waiting\", on démarre\n          if (msg.peers === 2 && status === \"waiting\") {\n            await startCall();\n          }\n          break;\n        case \"offer\":\n          await pcRef.current.setRemoteDescription(msg.offer);\n          await createAndSendAnswer();\n          break;\n        case \"answer\":\n          await pcRef.current.setRemoteDescription(msg.answer);\n          break;\n        case \"candidate\":\n          if (msg.candidate) {\n            await pcRef.current.addIceCandidate(msg.candidate);\n          }\n          break;\n        case \"end-call\":\n          hangUp();\n          break;\n      }\n    };\n    ws.onclose = () => console.log(\"WS ▶︎ closed\");\n    return () => {\n      var _pcRef$current;\n      ws.close();\n      (_pcRef$current = pcRef.current) === null || _pcRef$current === void 0 ? void 0 : _pcRef$current.close();\n    };\n  }, [callId, start, status]);\n\n  // 3) Démarrage du call\n  async function startCall() {\n    setStatus(\"connecting\");\n    const pc = new RTCPeerConnection({\n      iceServers: [{\n        urls: process.env.REACT_APP_STUN_SERVER\n      }]\n    });\n    pcRef.current = pc;\n\n    // a) mettre à jour status en fonction de connectionState\n    pc.onconnectionstatechange = () => {\n      const state = pc.connectionState;\n      console.log(\"PC state →\", state);\n      if (state === \"connected\") setStatus(\"connected\");else if (state === \"connecting\") setStatus(\"connecting\");else if (state === \"disconnected\" || state === \"failed\") setStatus(\"peer-left\");\n    };\n\n    // b) ICE candidates\n    pc.onicecandidate = ({\n      candidate\n    }) => {\n      if (candidate) {\n        wsRef.current.send(JSON.stringify({\n          type: \"candidate\",\n          candidate\n        }));\n      }\n    };\n\n    // c) réception stream distant\n    pc.ontrack = ({\n      streams: [stream]\n    }) => {\n      if (remoteAudioRef.current) {\n        remoteAudioRef.current.srcObject = stream;\n      }\n    };\n\n    // d) ajouter local stream\n    const localStream = localStreamRef.current;\n    if (localStream) {\n      localStream.getTracks().forEach(t => pc.addTrack(t, localStream));\n    }\n\n    // e) DataChannel\n    if (isInitiator) {\n      const dc = pc.createDataChannel(\"chat\");\n      dcRef.current = dc;\n      setupDataChannel(dc);\n    } else {\n      pc.ondatachannel = ({\n        channel\n      }) => {\n        dcRef.current = channel;\n        setupDataChannel(channel);\n      };\n    }\n\n    // f) offer / answer\n    if (isInitiator) {\n      const offer = await pc.createOffer();\n      await pc.setLocalDescription(offer);\n      wsRef.current.send(JSON.stringify({\n        type: \"offer\",\n        offer\n      }));\n    }\n  }\n  async function createAndSendAnswer() {\n    const pc = pcRef.current;\n    const answer = await pc.createAnswer();\n    await pc.setLocalDescription(answer);\n    wsRef.current.send(JSON.stringify({\n      type: \"answer\",\n      answer\n    }));\n  }\n\n  // 4) Chat\n  function setupDataChannel(dc) {\n    dc.onopen = () => setIsChannelOpen(true);\n    dc.onclose = () => setIsChannelOpen(false);\n    dc.onmessage = ({\n      data\n    }) => setChatMessages(msgs => [...msgs, {\n      sender: \"peer\",\n      text: data\n    }]);\n  }\n  function sendMessage(text) {\n    var _dcRef$current;\n    setChatMessages(msgs => [...msgs, {\n      sender: \"local\",\n      text\n    }]);\n    if (((_dcRef$current = dcRef.current) === null || _dcRef$current === void 0 ? void 0 : _dcRef$current.readyState) === \"open\") dcRef.current.send(text);\n  }\n\n  // 5) commandes UI\n  function toggleMute() {\n    var _localStreamRef$curre;\n    const t = (_localStreamRef$curre = localStreamRef.current) === null || _localStreamRef$curre === void 0 ? void 0 : _localStreamRef$curre.getAudioTracks()[0];\n    if (t) t.enabled = !t;\n  }\n  function hangUp() {\n    var _localStreamRef$curre2, _pcRef$current2;\n    setStatus(\"ended\");\n    (_localStreamRef$curre2 = localStreamRef.current) === null || _localStreamRef$curre2 === void 0 ? void 0 : _localStreamRef$curre2.getTracks().forEach(t => t.stop());\n    (_pcRef$current2 = pcRef.current) === null || _pcRef$current2 === void 0 ? void 0 : _pcRef$current2.close();\n    wsRef.current.send(JSON.stringify({\n      type: \"end-call\"\n    }));\n    wsRef.current.close();\n  }\n  return {\n    remoteAudioRef,\n    status,\n    chatMessages,\n    sendMessage,\n    toggleMute,\n    hangUp,\n    isChannelOpen\n  };\n}\n_s(useWebRTC, \"p5i2A/V4Uu+rGENNHEA/ZQGSYOw=\");","map":{"version":3,"names":["useEffect","useRef","useState","useWebRTC","callId","start","isInitiator","_s","status","setStatus","wsRef","pcRef","dcRef","localStreamRef","remoteAudioRef","chatMessages","setChatMessages","isChannelOpen","setIsChannelOpen","navigator","mediaDevices","getUserMedia","audio","then","stream","current","catch","err","console","error","ws","WebSocket","process","env","REACT_APP_SERVER_URL","replace","onopen","log","onmessage","data","msg","JSON","parse","type","peers","startCall","setRemoteDescription","offer","createAndSendAnswer","answer","candidate","addIceCandidate","hangUp","onclose","_pcRef$current","close","pc","RTCPeerConnection","iceServers","urls","REACT_APP_STUN_SERVER","onconnectionstatechange","state","connectionState","onicecandidate","send","stringify","ontrack","streams","srcObject","localStream","getTracks","forEach","t","addTrack","dc","createDataChannel","setupDataChannel","ondatachannel","channel","createOffer","setLocalDescription","createAnswer","msgs","sender","text","sendMessage","_dcRef$current","readyState","toggleMute","_localStreamRef$curre","getAudioTracks","enabled","_localStreamRef$curre2","_pcRef$current2","stop"],"sources":["/Users/theodiamant/Desktop/webrtc/client/src/hooks/useWebRTC.js"],"sourcesContent":["// src/hooks/useWebRTC.js\nimport { useEffect, useRef, useState } from \"react\";\n\nexport default function useWebRTC(\n  callId,\n  { start = true, isInitiator = false }\n) {\n  const [status, setStatus] = useState(\"waiting\"); // waiting → connecting → connected → peer-left → ended\n  const wsRef = useRef(null);\n  const pcRef = useRef(null);\n  const dcRef = useRef(null);\n  const localStreamRef = useRef(null);\n  const remoteAudioRef = useRef(null);\n  const [chatMessages, setChatMessages] = useState([]);\n  const [isChannelOpen, setIsChannelOpen] = useState(false);\n\n  // 1) getUserMedia une seule fois\n  useEffect(() => {\n    navigator.mediaDevices\n      .getUserMedia({ audio: true })\n      .then((stream) => (localStreamRef.current = stream))\n      .catch((err) => console.error(\"Micro inaccessible :\", err));\n  }, []);\n\n  // 2) Signaling\n  useEffect(() => {\n    if (!start) return;\n    const ws = new WebSocket(\n      process.env.REACT_APP_SERVER_URL.replace(/^http/, \"ws\") + `?roomId=${callId}`\n    );\n    wsRef.current = ws;\n    ws.onopen = () => console.log(\"WS ▶︎ open\");\n    ws.onmessage = async ({ data }) => {\n      const msg = JSON.parse(data);\n      switch (msg.type) {\n        case \"room-status\":\n          // Dès qu'on a 2 peers et qu'on est encore en \"waiting\", on démarre\n          if (msg.peers === 2 && status === \"waiting\") {\n            await startCall();\n          }\n          break;\n        case \"offer\":\n          await pcRef.current.setRemoteDescription(msg.offer);\n          await createAndSendAnswer();\n          break;\n        case \"answer\":\n          await pcRef.current.setRemoteDescription(msg.answer);\n          break;\n        case \"candidate\":\n          if (msg.candidate) {\n            await pcRef.current.addIceCandidate(msg.candidate);\n          }\n          break;\n        case \"end-call\":\n          hangUp();\n          break;\n      }\n    };\n    ws.onclose = () => console.log(\"WS ▶︎ closed\");\n    return () => {\n      ws.close();\n      pcRef.current?.close();\n    };\n  }, [callId, start, status]);\n\n  // 3) Démarrage du call\n  async function startCall() {\n    setStatus(\"connecting\");\n    const pc = new RTCPeerConnection({\n      iceServers: [{ urls: process.env.REACT_APP_STUN_SERVER }],\n    });\n    pcRef.current = pc;\n\n    // a) mettre à jour status en fonction de connectionState\n    pc.onconnectionstatechange = () => {\n      const state = pc.connectionState;\n      console.log(\"PC state →\", state);\n      if (state === \"connected\") setStatus(\"connected\");\n      else if (state === \"connecting\") setStatus(\"connecting\");\n      else if (state === \"disconnected\" || state === \"failed\") setStatus(\"peer-left\");\n    };\n\n    // b) ICE candidates\n    pc.onicecandidate = ({ candidate }) => {\n      if (candidate) {\n        wsRef.current.send(JSON.stringify({ type: \"candidate\", candidate }));\n      }\n    };\n\n    // c) réception stream distant\n    pc.ontrack = ({ streams: [stream] }) => {\n      if (remoteAudioRef.current) {\n        remoteAudioRef.current.srcObject = stream;\n      }\n    };\n\n    // d) ajouter local stream\n    const localStream = localStreamRef.current;\n    if (localStream) {\n      localStream.getTracks().forEach((t) => pc.addTrack(t, localStream));\n    }\n\n    // e) DataChannel\n    if (isInitiator) {\n      const dc = pc.createDataChannel(\"chat\");\n      dcRef.current = dc;\n      setupDataChannel(dc);\n    } else {\n      pc.ondatachannel = ({ channel }) => {\n        dcRef.current = channel;\n        setupDataChannel(channel);\n      };\n    }\n\n    // f) offer / answer\n    if (isInitiator) {\n      const offer = await pc.createOffer();\n      await pc.setLocalDescription(offer);\n      wsRef.current.send(JSON.stringify({ type: \"offer\", offer }));\n    }\n  }\n\n  async function createAndSendAnswer() {\n    const pc = pcRef.current;\n    const answer = await pc.createAnswer();\n    await pc.setLocalDescription(answer);\n    wsRef.current.send(JSON.stringify({ type: \"answer\", answer }));\n  }\n\n  // 4) Chat\n  function setupDataChannel(dc) {\n    dc.onopen = () => setIsChannelOpen(true);\n    dc.onclose = () => setIsChannelOpen(false);\n    dc.onmessage = ({ data }) =>\n      setChatMessages((msgs) => [...msgs, { sender: \"peer\", text: data }]);\n  }\n  function sendMessage(text) {\n    setChatMessages((msgs) => [...msgs, { sender: \"local\", text }]);\n    if (dcRef.current?.readyState === \"open\") dcRef.current.send(text);\n  }\n\n  // 5) commandes UI\n  function toggleMute() {\n    const t = localStreamRef.current?.getAudioTracks()[0];\n    if (t) t.enabled = !t;\n  }\n  function hangUp() {\n    setStatus(\"ended\");\n    localStreamRef.current?.getTracks().forEach((t) => t.stop());\n    pcRef.current?.close();\n    wsRef.current.send(JSON.stringify({ type: \"end-call\" }));\n    wsRef.current.close();\n  }\n\n  return {\n    remoteAudioRef,\n    status,\n    chatMessages,\n    sendMessage,\n    toggleMute,\n    hangUp,\n    isChannelOpen,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}